---
title: Java继承的覆盖与隐藏
id: 21
aliases:
  - /blog/21/
categories:
  - Java
date: 2018-01-21T22:39:20+08:00
tags:
---

参考：
[https://www.cnblogs.com/it12345/p/5221673.html](https://www.cnblogs.com/it12345/p/5221673.html)

### 隐藏和覆盖的区别

**隐藏：将类型转换为父类的类型 即可解除 隐藏
覆盖：将类型转换为父类的类型也 不能 解除覆盖**

### 成员变量

**只可能被隐藏，不存在覆盖一说**

父类的成员变量静态或非静态都可能被子类中同名的成员变量 隐藏 （不一定要匹配类型，同名即可隐藏）

#### 处理

**直接用圆点运算符父类中的成员变量的办法：将类型转换为父类的类型。**
**在子类的方法中调用父类中被隐藏的成员变量的办法：在子类方法中使用super关键字配合圆点运算符取父类中的成员变量。**

### 成员方法

可以被隐藏，也可以被覆盖
同名的实例方法被覆盖 ，同名的静态方法被隐藏

#### 补充：继承规则

子类中与父类同名同参的方法才会发生重写，
重写时：
1.要求重写的方法的静态与非静态属性相同，
2.要求重写的方法的返回值类型相同，
3.重写后方法的可访问性必须更开放或不变，例如：private->public
不满足这三条的程序将报错无法通过编译

**若重写了实例方法，则发生覆盖**
** 若重写了静态方法，则发生隐藏**

#### 处理

**通过反射能直接调用被“覆盖”的父类的方法的目的**
**无法在外部调用被“覆盖”的父类方法，只能在子类的内部使用super关键字配合圆点运算符调用父类的方法**
**无法通过转换类型达到调用被“覆盖”的父类的方法的目的**


### 关于方法中使用到成员变量的问题

**所取用的成员变量是子类中的还是父类中的取决于实际被调用的方法是在父类中还是子类中，以实际被调用的方法所在位置来观察可以判断出使用的是哪里的成员变量。**

例如：

```
public class Main {
	public static void main(String[] args) {

		Ch ch = new Ch();
		ch.show();
	}
}

class Su{
	int a = 3;//被隐藏
	String b ="what";//被隐藏
	void show() {//被覆盖
		System.out.println(a);
		System.out.println(b);
	}
}
class Ch extends Su{
	float a = 1.23f;//发生隐藏
	boolean b = false;//发生隐藏

	void show() {//发生覆盖
		System.out.println(a);
		System.out.println(b);
		super.show();
	}
}

/**
 * 输出：
 * 1.23
 * false
 * 3
 * what
 * 
*/

```
