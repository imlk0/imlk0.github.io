<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>TrustZone for Armv8-A 概念梳理 | imlk's blog</title><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=/css/fonts.css><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@400;700&display=swap" rel=stylesheet></head><body><header class=header><a class=logo href=/>imlk's Blog</a><nav><ul class=menu><li><a href=/>🏠Home</a></li><li><a href=/about/>👋About</a></li><li><a href=/archives/>📜Archives</a></li><li><a href=/friends/>🔗Friends</a></li><li><a href=/dn42/>🕸️DN42</a></li><li><a href=/index.xml>📢Subscribe</a></li></ul></nav></header><hr><div class=article-meta><h1><span class=title>TrustZone for Armv8-A 概念梳理</span></h1><span><span class=date>📅 2021-10-07</span>
<span class=date>(更新于2023-08-30)</span>
/
<span class=cats>📚
<a href=https://blog.imlk.top/categories/tee/>TEE</a></span>
/
<span class=tags>🏷️
<a href=https://blog.imlk.top/tags/trustzone/>#TrustZone</a>
<a href=https://blog.imlk.top/tags/security/>#Security</a>
<a href=https://blog.imlk.top/tags/reading/>#Reading</a></span></span><br></div><main class=post-content><h1 id=trustzone-for-armv8-a>TrustZone for Armv8-A</h1><h1 id=links>Links</h1><ul><li><a href=https://developer.arm.com/architectures/learn-the-architecture/trustzone-for-aarch64>https://developer.arm.com/architectures/learn-the-architecture/trustzone-for-aarch64</a></li></ul><h1 id=key-points>key points</h1><ul><li><p>EL3在任何时候都应该被归类于Secure state的一部分</p></li><li><p>地址空间</p><ul><li>S.EL0/1和NS.EL0/1分别属于两个<strong>不同且独立的虚拟地址空间</strong>，在安全状态不会使用NS.EL0/1的地址转换，同样，在非安全状态不会适应S.EL0/1的地址转换。</li><li><strong>物理地址空间被划分为Secure和Non-secure</strong><ul><li><p>Non-secure world的虚地址只能被翻译到Non-secure的物理地址空间</p></li><li><p><strong>Secure world的软件可以访问Secure和Non-secure两种物理地址空间</strong></p></li><li><p>为了区分这两个物理地址空间，物理地址使用前缀<code>NP:</code>和<code>SP:</code>来标识。<strong>虽然物理地址一样，但是因为前缀不一样，它们就表示不同的内存位置（存的数据可以不一样）</strong>，就好像他们在地址总线上多了位一样：</p><p><img src=/images/TrustZone%20for%20Armv8-A%2088d036d115df467e818205433b986fa7/Untitled.png alt=Untitled></p><ul><li>cache的tag中也包含了这个指示位，Non-secure状态下无法影响Secure状态的cache。</li></ul></li></ul></li></ul></li><li><p>SMC</p><ul><li>执行SMC（secure monitor call）时，硬件不会自动进行寄存器值的备份，需要编写软件实现。</li><li><strong>在EL1执行的SMC可以被在EL2的hypervisor拦截</strong>，因为hypervisor可能通过这种方式模拟虚拟机所看到的固件接口（firmware interface）。</li><li><strong>SMC指令不能在EL0或者Security state时执行</strong></li></ul></li><li><p>关于虚拟化</p><ul><li><p>从虚拟化从Armv7-A引入直至Armv8.3之前，EL2只在Non-secure世界存在。从Armv8.4-A开始，Secure世界也可以存在EL2了，处于这些考虑：</p><ul><li>一些TA可能依赖于在特定的TOS上运行，这意味着要运行多个Trusted kernels，</li><li>出于最小化特权原则，firmware中的一些功能需要被移出EL3</li></ul><p><img src=/images/TrustZone%20for%20Armv8-A%2088d036d115df467e818205433b986fa7/Untitled%201.png alt=Untitled></p></li><li><p>与完整的hypervisor程序不同，S.EL2通常托管安全分区管理器（Secure partition manager，SPM），它允许创建隔离分区，这些分区无法查看其他分区的资源。每个分区可以运行各自的TOS和Trusted Services</p></li></ul></li><li><p>系统架构System architecture</p><p><img src=/images/TrustZone%20for%20Armv8-A%2088d036d115df467e818205433b986fa7/Untitled%202.png alt=Untitled></p><ul><li><p>bus secure & bus non-secure</p><ul><li>bus secure意味着当前总线只能访问安全地址空间；bus non-secure 意味着只能访问非安全地址空间。这是由总线上的<code>AxPROT[1]</code>位定义的</li><li>但是bus secure和non-secure并非由当前处理器的secure state决定，因为secure state的processor也可以发起bus non-secure的访问。</li></ul></li><li><p><strong>对bus slaves的访问控制</strong>：</p><p>为支持TrustZone，通过processor和外设之间的**互联系统（Interconnect system）**将外设分为4类别：</p><p><img src=/images/TrustZone%20for%20Armv8-A%2088d036d115df467e818205433b986fa7/Untitled%203.png alt=Untitled></p><ul><li><strong>Secure</strong>: 只能在bus secure时访问，拒绝non-secure访问</li><li><strong>Non-secure</strong>: 只能被bus non-secure时访问</li><li><strong>Boot time configurable</strong>: 在启动时，系统初始化软件可以控制设备为Secure或者Non-secure。（默认是Secure）</li><li><strong>TrustZone aware</strong>: 互联系统允许任何类型的访问通过，这意味着被连接的设备需要自己实现隔离(isolation)<ul><li><p>一个例子是对于片外DDR内存，可以在processor和DDR加入一个<code>TZASC(TrustZone Address Space Controller)</code>并对互联系统设计为TrustZone aware，然后由TZASC来控制对内存的安全访问。同时对TZASC自身的访问又是Secure only的</p><p><img src=/images/TrustZone%20for%20Armv8-A%2088d036d115df467e818205433b986fa7/Untitled%204.png alt=Untitled></p></li></ul></li></ul></li><li><p><strong>对bus masters的访问控制：</strong></p><p>总线上除了processor，还可能有一些别的masters，如GPU和DMA Controller。这些设备的总线访问控制被分为下面几类：</p><ul><li><strong>TrustZone aware</strong>：这类master（包括processer）包含对TrustZone的感知能力，能够为总线访问提供适当的安全信息（即能够主动设置bus的安全位）</li><li><strong>Non-TrustZone aware</strong>：不感知TrustZone,如一些老的IP，解决办法有下面几种：<ul><li><strong>Design time tie-off</strong>：如果该master只需要访问non-secure或者只需访问secure地址空间，设计人员可以将相应的位设为固定值。</li><li><strong>Configurable logic</strong>：一些互联系统如（NIC-400）允许在启动时再将某个master设置为允许访问non-secure或者secure地址空间。与上面的那类类似不过推迟到了系统启动时再设定。</li><li><strong>SMMU(System MMU)</strong>：更灵活的一种方案，它就像processor里的MMU一样。在不支持TrustZone的master前面套一个SMMU，这样在该master发出访问时，会通过对应页表的属性来配置bus的安全位。</li></ul></li></ul></li><li><p>中断处理</p><ul><li><p><code>FIQ(Fast Interrupt Request)</code>和<code>IRQ(Interrupt Request)</code>，是arm中的两种类型的中断：</p><ul><li><code>FIQ</code>优先级比<code>IRQ</code>高，可以打断<code>IRQ</code>，并且<code>FIQ</code>有一些专用的寄存器<code>r8-r14</code>，这意味着<code>FIQ</code>的速度会快很多。<a href=https://stackoverflow.com/questions/973933/what-is-the-difference-between-fiq-and-irq-interrupt-system>参阅</a></li></ul></li><li><p>通用中断控制器<code>Generic Interrupt Controller (GIC)</code>，可以连接到多个core。</p><p><img src=/images/TrustZone%20for%20Armv8-A%2088d036d115df467e818205433b986fa7/Untitled%205.png alt=Untitled></p></li><li><p>在GIC规范中，每个中断源被定义为一个<code>INTID</code>。</p></li><li><p><code>**INTID</code>整体上可以分两类，Secure 与 Non-secure。每个<code>INTID</code>被划分到三个groups中的一个**，且可在运行时动态修改。<strong>GIC通过<code>INTID</code>所在的group和当前的security state来决定发出<code>FIQ</code>还是<code>IRQ</code>中断：</strong></p><ul><li>Group 0: Secure interrupt, signaled as FIQ<ul><li>划分到该组的<code>INTID</code> 是一些被EL3处理的中断。</li><li>当中断到来时，总是以<code>FIQ</code>形式通知</li></ul></li><li>Secure Group 1: Secure interrupt, signaled as IRQ or FIQ<ul><li>其余安全中断源都会被划分到这里，在<code>S.EL1</code>或者<code>S.EL2</code>中被处理。</li><li>如果processor当前是Secure state，则触发<code>IRQ</code> ，如果是Non-secure state，则触发<code>FIQ</code>。</li></ul></li><li>Non-secure Group 1: Non-secure interrupt, signaled as IRQ or FIQ<ul><li>非安全中断源</li><li>如果processor当前是Secure state，则触发<code>FIQ</code>，如果是Non-secure state，则触发<code>IRQ</code>。</li></ul></li></ul><p><img src=/images/TrustZone%20for%20Armv8-A%2088d036d115df467e818205433b986fa7/Untitled%206.png alt=一种常见的配置></p><p>一种常见的配置</p></li><li><p>对<code>INTID</code>的访问控制？</p><ul><li>对于配置为Secure的<code>INTID</code>，只有bus secure的访问才可以修改它的状态和配置，否则将读取到<code>0</code>值。对于配置为Non-secure的<code>INTID</code>，bus secure和bus non-secure的访问都可以对它修改状态和配置。</li></ul></li></ul></li><li><p>调试，跟踪和分析</p><p>（略）</p></li><li><p>其余设备</p><p><img src=/images/TrustZone%20for%20Armv8-A%2088d036d115df467e818205433b986fa7/Untitled%207.png alt=Untitled></p><ul><li>一次性编程区域 One-time programmable memory (OTP) or fuses<ul><li>可以被编程为<strong>设备唯一值（device unique values）<strong>和</strong>OEM的唯一值（OEM unique values）</strong></li><li>**设备唯一私钥（device unique private key）**可以被写入在这里，在制造时随机生成唯一密钥。该密钥用于将数据绑定到该芯片。</li><li>可以写入OEM公钥的hash值</li></ul></li><li>非易失性计数器（Non-volatile(NV) counter）<ul><li>一个只能递增且无法重置的计数器，用于防止回滚攻击。<ul><li>在每次固件更新后增加计数器的值，在启动时，固件的版本会被和NV的值进行比较，防止回滚</li></ul></li></ul></li><li>可信RAM和可信ROM（Trusted RAM and Trusted ROM）<ul><li>片上的仅限secure访问的内存。片上意味着<strong>攻击者无法替换</strong>。</li><li>Trusted ROM：<strong>读取第一个引导代码（first boot code）的地方</strong>。ROM意味着无法重新改写。这意味着我们有<strong>一个已知的、可信的执行起点。</strong></li><li>Trust RAM：通常是几百KB的SRAM，<strong>是在安全状态下运行的软件的工作内存</strong>。</li></ul></li></ul><p>（略）</p></li></ul></li><li><p>软件架构Software architecture</p><ul><li><p>**可信服务TS和非安全世界的通信：<strong>通常使用内存中的</strong>消息队列（message queues）<strong>或者</strong>邮箱（mailboxs）**来实现（注意这个mailbox似乎位于内存中，与核间通信的那个和中断有关的mailbox机制似乎不太一样）。世界共享内存<code>World Shared Memory (WSM)</code>有时被用于描述这种通信，这些内存位于非安全区域（因为这样一来安全世界也能访问）。</p><ul><li><p>通常是：非安全世界的程序向mailbox中放入一系列请求(requests)，然后调用内核驱动。后者负责和TEE之间的低级通信，如为消息队列分配内存并将其注册到TEE。之后内核驱动调用SMC将控制权交由EL3，TOS的kernel调用所请求的TS，后者从消息队列读取并处理请求。</p><p><img src=/images/TrustZone%20for%20Armv8-A%2088d036d115df467e818205433b986fa7/Untitled%208.png alt=Untitled></p></li></ul></li><li><p><strong>Scheduling：</strong></p><ul><li>一些服务会明确调用EL3层的firmware。例如，电源管理请求Power State Coordination Interface (PSCI)。它通常是阻塞的，这意味着当操作完成时，控制权才会回到non-secure world。</li><li>TEE的运行在non-secure中的scheduler的控制之下。意味着DoS攻击难以避免，存在<strong>可用性问题</strong>。<ul><li>一个典型实现是：在Rich OS运行一个daemon，它负责接收请求SMC将控制权交给TEE。随后TEE运行并处理未完成的请求。<strong>直到下一个调度器信号（scheduler tick）或者中断信号，才将控制权交回给Rich OS。</strong></li></ul></li><li>可用性问题的解决办法<ul><li>设计软件栈来提供可用性。GIC允许Secure interrupts的优先级高于Non-secure interrupts，以防止在非安全状态下阻止Secure interrupts的发生。</li></ul></li></ul></li><li><p>TEE与Non-secure虚拟化环境的交互</p><ul><li><p>虚拟化环境（<code>NS.EL0</code>/<code>NS.EL1</code>）中使用SMC来访问firmware function和Trusted service function。其中一个例子是firmware function中包括电源管理相关的功能。为了虚拟化这一部分，这些firmware function会被<code>NS.EL2</code> 层的hypervisor拦截并以模拟的方式来替代。</p><p><img src=/images/TrustZone%20for%20Armv8-A%2088d036d115df467e818205433b986fa7/Untitled%209.png alt=Untitled></p></li></ul></li><li><p>启动与信任链（chain of trust）</p><p><img src=/images/TrustZone%20for%20Armv8-A%2088d036d115df467e818205433b986fa7/Untitled%2010.png alt=Untitled></p><ul><li><strong>boot ROM</strong>：这部分通常非常小而且简单，功能是从闪存(flash)中加载和验证第二阶段引导代码(second stage boot code)。<ul><li>在ROM中，可以避免改写</li><li>在芯片上，防止被替换</li></ul></li><li><strong>second stage boot code</strong>: 位于flash中。执行系统初始化，如<ul><li>为片外DRAM启动memory controller</li><li>加载并验证将在Secure state和Non-secure state运行的映像文件。如TEE和UEFI。另外，Trusted Firmware（EL3）也由该阶段所启动。</li></ul></li></ul></li><li><p>Trusted Firmware</p><p><img src=/images/TrustZone%20for%20Armv8-A%2088d036d115df467e818205433b986fa7/Untitled%2011.png alt=Untitled></p><ul><li>Trusted Firmware是一个安全世界软件的开源实现<ul><li>SMC Dispatcher 负责处理传入的SMC，决定哪些在EL3处理，哪些被转发到TEE。</li><li>还提供了处理system IP（比如互连interconnect系统）的代码。芯片供应商需要提供处理定制IP或者第三方的IP的代码，包括特定于SoC（SoC-specific）的电源管理。</li></ul></li></ul></li><li><p>Encrypted filesystem 加密文件系统</p><ul><li><p>在一些场景下，用户数据需要文件系统级的加密，防止设备丢失后的数据窃取。在通过用户的验证后，才允许解密文件系统。文件系统解密流程如下：</p><p><img src=/images/TrustZone%20for%20Armv8-A%2088d036d115df467e818205433b986fa7/Untitled%2012.png alt=Untitled></p><ul><li>Encrypted Filesystem Key被载入到片内可信RAM中，使用片内的一次编程的master device unique key解密。</li><li>将解密后 的Filesystem Key传输到一个只能Secure状态下访问的，加密引擎(crypto engine)或内存控制器(memory controller)的寄存器中。</li><li>之后对flash中的文件系统的访问都将使用寄存器中设定的密钥进行加解密。</li></ul></li></ul></li><li><p>固件firmware的OTA升级</p><ul><li>固件升级要求保证可信性、不可回滚性。通常使用以下方案：<ul><li>新firmware的image在Non-secure环境获得，并不保证其机密性，但是通过签名和OEM公钥来保证其完整性。image被放置在内存中，并向Secure state发出安装请求。</li><li>Secure state中的代码负责认证，使用OEM的公钥来保证。OEM通常存在片外flash中，因此它也不保证机密性。但可以通过在片内存储OEM公钥的hash来保证其真实性(authenticity)，因为片上存储很贵。</li><li>假设通过检查，那么image将被安装，并且NV计数器将会增加</li></ul></li></ul><p><img src=/images/TrustZone%20for%20Armv8-A%2088d036d115df467e818205433b986fa7/Untitled%2013.png alt=Untitled></p></li><li><p>Trusted Base System Architecture (TBSA): gives guidance on system architecture.</p></li><li><p>Trusted Board Boot Requirements (TBBR): gives guidance on booting.</p></li></ul></li></ul></main><div id=comments><hr><script src=https://utteranc.es/client.js repo=KB5201314/KB5201314.github.io issue-term=pathname label='💬 comments 💬' theme=github-light crossorigin=anonymous async></script></div><footer class=footer><hr>© imlk 2017 &ndash; 2023 | <a href=https://blog.imlk.top>imlk's blog</a> | <a href=https://github.com/KB5201314/>Github</a> | <a href=mailto:me@imlk.top>Email</a> | <a href=https://beian.miit.gov.cn/>京ICP备2020042968号-1</a></footer></body></html>