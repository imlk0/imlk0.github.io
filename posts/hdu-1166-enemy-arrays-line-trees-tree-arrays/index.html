<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>HDU 1166 æ•Œå…µå¸ƒé˜µâ€”â€”çº¿æ®µæ ‘ï¼Œæ ‘çŠ¶æ•°ç»„ | imlk's blog</title>
<link rel=stylesheet href=/css/style.css><link rel=stylesheet href=/css/fonts.css><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@400;700&display=swap" rel=stylesheet></head><body><header class=header><a class=logo href=/>imlk's Blog</a><nav><ul class=menu><li><a href=/>ğŸ Home</a></li><li><a href=/about/>ğŸ‘‹About</a></li><li><a href=/archives/>ğŸ“œArchives</a></li><li><a href=/friends/>ğŸ”—Friends</a></li><li><a href=/dn42/>ğŸ•¸ï¸DN42</a></li><li><a href=/index.xml>ğŸ“¢Subscribe</a></li></ul></nav></header><hr><div class=article-meta><h1><span class=title>HDU 1166 æ•Œå…µå¸ƒé˜µâ€”â€”çº¿æ®µæ ‘ï¼Œæ ‘çŠ¶æ•°ç»„</span></h1><span><span class=date>ğŸ“… 2018-02-06</span>
<span class=date>(æ›´æ–°äº2021-10-10)</span>
/
<span class=cats>ğŸ“š
<a href=https://blog.imlk.top/categories/algorithm/>Algorithm</a>
</span>/
<span class=tags>ğŸ·ï¸
<a href=https://blog.imlk.top/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/>#çº¿æ®µæ ‘</a></span></span><br></div><main class=post-content><p>è¿™é¢˜æœ¬æ¥æˆ‘æ‰“ç®—ç”¨å‰ç¼€æ•°ç»„å®ç°æºæ•°æ®çš„å¤„ç†ï¼Œå¹¶æŠŠæ›´å˜ç”¨map&lt;int ,int>å®ç°ï¼Œå‘ç°åæ¥è¿˜æ˜¯è¶…æ—¶äº†ï¼›</p><p>å€Ÿæœºå­¦ä¹ äº†ä¸€ä¸‹çº¿æ®µæ ‘ï¼Œè™½ç„¶æ²¡æ€ä¹ˆçœ‹æ‡‚ï¼Œä½†å¤§æ¦‚è¿˜æ˜¯ç†è§£äº†ä¸€ç‚¹ï¼›
è¿™é¢˜ç”¨ æŒ‡é’ˆæ„æˆçš„çº¿æ®µæ ‘ å’Œ æ•°ç»„æ„æˆçš„çº¿æ®µæ ‘ åˆ†åˆ«æ¥å®ç°äº†ä¸€ä¸‹
èµ„æ–™ï¼š
çº¿æ®µæ ‘ä»é›¶å¼€å§‹ - CSDNåšå®¢
<a href=http://blog.csdn.net/zearot/article/details/52280189>http://blog.csdn.net/zearot/article/details/52280189</a>
çº¿æ®µæ ‘è¯¦è§£ ï¼ˆåŸç†ï¼Œå®ç°ä¸åº”ç”¨ï¼‰ - CSDNåšå®¢
<a href=http://blog.csdn.net/zearot/article/details/48299459>http://blog.csdn.net/zearot/article/details/48299459</a>
çœ‹åˆ°æœ‰äººç”¨æ ‘çŠ¶æ•°ç»„å®ç°ï¼Œå­¦ä¹ äº†ä¸€ä¸‹æ ‘çŠ¶æ•°ç»„ï¼Œä»£ç è´´åœ¨æœ€åï¼š
èµ„æ–™ï¼š
æ ‘çŠ¶æ•°ç»„å…¥é—¨
<a href=https://www.cnblogs.com/hsd-/p/6139376.html>https://www.cnblogs.com/hsd-/p/6139376.html</a></p><p>é¢˜ç›®æ¥æºï¼š<a href="http://acm.hdu.edu.cn/showproblem.php?pid=1166">http://acm.hdu.edu.cn/showproblem.php?pid=1166</a></p><blockquote><p>æ•Œå…µå¸ƒé˜µ
Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 65536/32768 K (Java/Others)
Total Submission(s): 106625 Accepted Submission(s): 44789</p><p>Problem Description
Cå›½çš„æ­»å¯¹å¤´Aå›½è¿™æ®µæ—¶é—´æ­£åœ¨è¿›è¡Œå†›äº‹æ¼”ä¹ ï¼Œæ‰€ä»¥Cå›½é—´è°å¤´å­Derekå’Œä»–æ‰‹ä¸‹Tidyåˆå¼€å§‹å¿™ä¹äº†ã€‚Aå›½åœ¨æµ·å²¸çº¿æ²¿ç›´çº¿å¸ƒç½®äº†Nä¸ªå·¥å…µè¥åœ°,Derekå’ŒTidyçš„ä»»åŠ¡å°±æ˜¯è¦ç›‘è§†è¿™äº›å·¥å…µè¥åœ°çš„æ´»åŠ¨æƒ…å†µã€‚ç”±äºé‡‡å–äº†æŸç§å…ˆè¿›çš„ç›‘æµ‹æ‰‹æ®µï¼Œæ‰€ä»¥æ¯ä¸ªå·¥å…µè¥åœ°çš„äººæ•°Cå›½éƒ½æŒæ¡çš„ä¸€æ¸…äºŒæ¥š,æ¯ä¸ªå·¥å…µè¥åœ°çš„äººæ•°éƒ½æœ‰å¯èƒ½å‘ç”Ÿå˜åŠ¨ï¼Œå¯èƒ½å¢åŠ æˆ–å‡å°‘è‹¥å¹²äººæ‰‹,ä½†è¿™äº›éƒ½é€ƒä¸è¿‡Cå›½çš„ç›‘è§†ã€‚
ä¸­å¤®æƒ…æŠ¥å±€è¦ç ”ç©¶æ•Œäººç©¶ç«Ÿæ¼”ä¹ ä»€ä¹ˆæˆ˜æœ¯,æ‰€ä»¥Tidyè¦éšæ—¶å‘Derekæ±‡æŠ¥æŸä¸€æ®µè¿ç»­çš„å·¥å…µè¥åœ°ä¸€å…±æœ‰å¤šå°‘äºº,ä¾‹å¦‚Dereké—®:â€œTidy,é©¬ä¸Šæ±‡æŠ¥ç¬¬3ä¸ªè¥åœ°åˆ°ç¬¬10ä¸ªè¥åœ°å…±æœ‰å¤šå°‘äºº!â€Tidyå°±è¦é©¬ä¸Šå¼€å§‹è®¡ç®—è¿™ä¸€æ®µçš„æ€»äººæ•°å¹¶æ±‡æŠ¥ã€‚ä½†æ•Œå…µè¥åœ°çš„äººæ•°ç»å¸¸å˜åŠ¨ï¼Œè€ŒDerekæ¯æ¬¡è¯¢é—®çš„æ®µéƒ½ä¸ä¸€æ ·ï¼Œæ‰€ä»¥Tidyä¸å¾—ä¸æ¯æ¬¡éƒ½ä¸€ä¸ªä¸€ä¸ªè¥åœ°çš„å»æ•°ï¼Œå¾ˆå¿«å°±ç²¾ç–²åŠ›å°½äº†ï¼ŒDerekå¯¹Tidyçš„è®¡ç®—é€Ÿåº¦è¶Šæ¥è¶Šä¸æ»¡:&ldquo;ä½ ä¸ªæ­»è‚¥ä»”ï¼Œç®—å¾—è¿™ä¹ˆæ…¢ï¼Œæˆ‘ç‚’ä½ é±¿é±¼!â€Tidyæƒ³ï¼šâ€œä½ è‡ªå·±æ¥ç®—ç®—çœ‹ï¼Œè¿™å¯çœŸæ˜¯ä¸€é¡¹ç´¯äººçš„å·¥ä½œ!æˆ‘æ¨ä¸å¾—ä½ ç‚’æˆ‘é±¿é±¼å‘¢!â€æ— å¥ˆä¹‹ä¸‹ï¼ŒTidyåªå¥½æ‰“ç”µè¯å‘è®¡ç®—æœºä¸“å®¶Windbreakeræ±‚æ•‘,Windbreakerè¯´ï¼šâ€œæ­»è‚¥ä»”ï¼Œå«ä½ å¹³æ—¶åšå¤šç‚¹acmé¢˜å’Œçœ‹å¤šç‚¹ç®—æ³•ä¹¦ï¼Œç°åœ¨å°åˆ°è‹¦æœäº†å§!â€Tidyè¯´ï¼š&ldquo;æˆ‘çŸ¥é”™äº†ã€‚ã€‚ã€‚&ldquo;ä½†Windbreakerå·²ç»æŒ‚æ‰ç”µè¯äº†ã€‚Tidyå¾ˆè‹¦æ¼ï¼Œè¿™ä¹ˆç®—ä»–çœŸçš„ä¼šå´©æºƒçš„ï¼Œèªæ˜çš„è¯»è€…ï¼Œä½ èƒ½å†™ä¸ªç¨‹åºå¸®ä»–å®Œæˆè¿™é¡¹å·¥ä½œå—ï¼Ÿä¸è¿‡å¦‚æœä½ çš„ç¨‹åºæ•ˆç‡ä¸å¤Ÿé«˜çš„è¯ï¼ŒTidyè¿˜æ˜¯ä¼šå—åˆ°Derekçš„è´£éª‚çš„.</p><p>Input
ç¬¬ä¸€è¡Œä¸€ä¸ªæ•´æ•°Tï¼Œè¡¨ç¤ºæœ‰Tç»„æ•°æ®ã€‚
æ¯ç»„æ•°æ®ç¬¬ä¸€è¡Œä¸€ä¸ªæ­£æ•´æ•°Nï¼ˆN&lt;=50000ï¼‰,è¡¨ç¤ºæ•Œäººæœ‰Nä¸ªå·¥å…µè¥åœ°ï¼Œæ¥ä¸‹æ¥æœ‰Nä¸ªæ­£æ•´æ•°,ç¬¬iä¸ªæ­£æ•´æ•°aiä»£è¡¨ç¬¬iä¸ªå·¥å…µè¥åœ°é‡Œå¼€å§‹æ—¶æœ‰aiä¸ªäººï¼ˆ1&lt;=ai&lt;=50ï¼‰ã€‚
æ¥ä¸‹æ¥æ¯è¡Œæœ‰ä¸€æ¡å‘½ä»¤ï¼Œå‘½ä»¤æœ‰4ç§å½¢å¼ï¼š
(1) Add i j,iå’Œjä¸ºæ­£æ•´æ•°,è¡¨ç¤ºç¬¬iä¸ªè¥åœ°å¢åŠ jä¸ªäººï¼ˆjä¸è¶…è¿‡30ï¼‰
(2)Sub i j ,iå’Œjä¸ºæ­£æ•´æ•°,è¡¨ç¤ºç¬¬iä¸ªè¥åœ°å‡å°‘jä¸ªäººï¼ˆjä¸è¶…è¿‡30ï¼‰;
(3)Query i j ,iå’Œjä¸ºæ­£æ•´æ•°,i&lt;=jï¼Œè¡¨ç¤ºè¯¢é—®ç¬¬iåˆ°ç¬¬jä¸ªè¥åœ°çš„æ€»äººæ•°;
(4)End è¡¨ç¤ºç»“æŸï¼Œè¿™æ¡å‘½ä»¤åœ¨æ¯ç»„æ•°æ®æœ€åå‡ºç°;
æ¯ç»„æ•°æ®æœ€å¤šæœ‰40000æ¡å‘½ä»¤</p><p>Output
å¯¹ç¬¬iç»„æ•°æ®,é¦–å…ˆè¾“å‡ºâ€œCase i:â€å’Œå›è½¦,
å¯¹äºæ¯ä¸ªQueryè¯¢é—®ï¼Œè¾“å‡ºä¸€ä¸ªæ•´æ•°å¹¶å›è½¦,è¡¨ç¤ºè¯¢é—®çš„æ®µä¸­çš„æ€»äººæ•°,è¿™ä¸ªæ•°ä¿æŒåœ¨intä»¥å†…ã€‚</p><p>Sample Input</p><p>1
10
1 2 3 4 5 6 7 8 9 10
Query 1 3
Add 3 6
Query 2 7
Sub 10 2
Add 6 3
Query 3 10
End</p><p>Sample Output</p><p>Case 1:
6
33
59</p><p>Author
Windbreaker</p><p>Recommend
Eddy | We have carefully selected several similar problems for you: 1394 1698 1754 1542 1540</p></blockquote><p>æŒ‡é’ˆçº¿æ®µæ ‘ï¼š</p><pre tabindex=0><code>#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;

using namespace std;

// çº¿æ®µæ ‘

struct Node {
	int lp;
	int rp;
	int mid;
	int sum;
	Node* left;
	Node* right;
	Node(int l, int r): lp(l), rp(r), mid((l + r) / 2), left(NULL), right(NULL) {}//newåˆå§‹åŒ–çš„å†…å­˜ä¸ä¸€å®šè‡ªåŠ¨å¡«0
};

int list[50005];//ä»1å¼€å§‹

int T, N, a, b;

Node* buildTree(int l, int r) {
	Node* p = new Node(l, r);
	if (l == r) {
		p-&gt;sum = list[l];
		return p;
	}
	p-&gt;left = buildTree(l, p-&gt;mid);
	p-&gt;right = buildTree(p-&gt;mid + 1, r);

	p-&gt;sum = p-&gt;left-&gt;sum + p-&gt;right-&gt;sum;
	return p;
}

void treeAdd(Node *which, int where, int what) {

	if (which-&gt;left != NULL &amp;&amp; which-&gt;right != NULL) {
		treeAdd((where &lt;= which-&gt;mid) ? which-&gt;left : which-&gt;right, where, what);
	}
	which-&gt;sum += what;
}

int calSum(Node * which, int from, int to) {

	if (from == which-&gt;lp &amp;&amp; to == which-&gt;rp) {
		return which-&gt;sum;
	}

	if (from &lt;= which-&gt;mid) {
		if (to &gt; which-&gt;mid) {//æ¨ªè·¨
			return calSum(which-&gt;left, from, which-&gt;mid) + calSum(which-&gt;right, which-&gt;mid + 1, to);
		} else {//å…¨åœ¨å·¦è¾¹
			return calSum(which-&gt;left, from, to);
		}
	} else {//å…¨åœ¨å³è¾¹
		return calSum(which-&gt;right, from, to);
	}

	return 0;
}

void del(Node * which) {
	if (which-&gt;left) {
		del(which-&gt;left);
	}
	if (which-&gt;right) {
		del(which-&gt;right);
	}

	delete which;
}

int main(int argc, char const *argv[])
{

	char cmd[10];
	scanf(&#34;%d&#34;, &amp;T);

	for (int t = 1; t &lt;= T; t++) {

		memset(list, 0, sizeof(list));

		scanf(&#34;%d&#34;, &amp;N);

		for (int i = 0; i &lt; N; i++) {
			scanf(&#34;%d&#34;, list + i);
		}

		Node* root = buildTree(0, N - 1);

		printf(&#34;Case %d:\n&#34;, t);
		while (1) {
			scanf(&#34;%s&#34;, cmd);
			if (&#39;E&#39; == cmd[0]) {
				break;
			}
			scanf(&#34;%d%d&#34;, &amp;a, &amp;b);
			switch (cmd[0]) {
			case &#39;Q&#39;:
				printf(&#34;%d\n&#34;, calSum(root, a - 1, b - 1));
				break;
			case &#39;A&#39;:
				list[a - 1] += b;
				treeAdd(root, a - 1, b);
				break;
			case &#39;S&#39;:
				list[a - 1] -= b;
				treeAdd(root, a - 1, -b);
				break;
			}
		}

		del(root);
		root = NULL;

	}

	return 0;
}
</code></pre><p>è‡ªå®šä¹‰ç»“æ„ä½“ç»„æˆçš„æ•°ç»„å®ç°çº¿æ®µæ ‘ï¼š</p><pre tabindex=0><code>#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;

using namespace std;

// çº¿æ®µæ ‘

struct Node {
	int lp;
	int rp;
	int mid;
	int sum;
} nodes[50005 &lt;&lt; 2];//ç©ºé—´ä¸ºåŸæ•°ç»„çš„å››å€é•¿ï¼Œ1å‚¨å­˜æ ¹å…ƒç´ ï¼Œå¯¹äºç¬¬kä¸ªèŠ‚ç‚¹ï¼ŒK&lt;&lt;1è¡¨ç¤ºå·¦æ”¯ï¼Œ(k&lt;&lt;1)|1è¡¨ç¤ºå³æ”¯

int list[50005];//ä»0å¼€å§‹

int T, N, a, b;

int buildTree(int which, int l, int r) {

	nodes[which].lp = l;
	nodes[which].rp = r;
	nodes[which].mid = ((l + r) &gt;&gt; 1);

	if (l == r) {
		nodes[which].sum = list[l];

	} else {
		nodes[which].sum += buildTree(which &lt;&lt; 1, l, (l + r) &gt;&gt; 1);
		nodes[which].sum += buildTree((which &lt;&lt; 1) | 1, ((l + r) &gt;&gt; 1) + 1, r);
	}

	return nodes[which].sum;
}

void treeAdd(int which, int where, int what) {

	if (nodes[which].lp != nodes[which].rp) {
		treeAdd((where &lt;= nodes[which].mid) ? which &lt;&lt; 1 : (which &lt;&lt; 1) | 1, where, what);
	}
	nodes[which].sum += what;
}

int calSum(int which, int from, int to) {

	// printf(&#34;from_%d,to_%d,and_now_is_%d,%d\n&#34;, from, to, nodes[which].lp, nodes[which].rp);
	if (from == nodes[which].lp &amp;&amp; to == nodes[which].rp) {
		return nodes[which].sum;
	}

	if (from &lt;= nodes[which].mid) {
		if (to &gt; nodes[which].mid) {//æ¨ªè·¨
			return calSum(which &lt;&lt; 1, from, nodes[which].mid) + calSum((which &lt;&lt; 1) | 1, nodes[which].mid + 1, to);
		} else {//å…¨åœ¨å·¦è¾¹
			return calSum(which &lt;&lt; 1, from, to);
		}
	} else {//å…¨åœ¨å³è¾¹
		return calSum((which &lt;&lt; 1) | 1, from, to);
	}

	return 0;
}

int main(int argc, char const *argv[])
{

	char cmd[10];
	scanf(&#34;%d&#34;, &amp;T);

	for (int t = 1; t &lt;= T; t++) {

		memset(list, 0, sizeof(list));
		memset(nodes, 0, sizeof(nodes));

		scanf(&#34;%d&#34;, &amp;N);

		for (int i = 0; i &lt; N; i++) {
			scanf(&#34;%d&#34;, list + i);
		}

		buildTree(1, 0, N - 1);

		printf(&#34;Case %d:\n&#34;, t);
		while (1) {
			scanf(&#34;%s&#34;, cmd);
			if (&#39;E&#39; == cmd[0]) {
				break;
			}
			scanf(&#34;%d%d&#34;, &amp;a, &amp;b);
			switch (cmd[0]) {
			case &#39;Q&#39;:
				printf(&#34;%d\n&#34;, calSum(1, a - 1, b - 1));
				break;
			case &#39;A&#39;:
				list[a - 1] += b;
				treeAdd(1, a - 1, b);
				break;
			case &#39;S&#39;:
				list[a - 1] -= b;
				treeAdd(1, a - 1, -b);
				break;
			}
		}

	}

	return 0;
}
</code></pre><p>æ ‘çŠ¶æ•°ç»„å®ç°ï¼šä»£ç é‡è¶…å°‘ï¼ï¼ï¼</p><pre tabindex=0><code>#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;

//Accept

#define lowbit(x) (x&amp;(-x))

//lowbit(x) å…¶å®ä»£è¡¨äº†ç¬¬xå·èŠ‚ç‚¹æœ€åº•å±‚ä»£è¡¨çš„åŒºé—´é•¿åº¦

using namespace std;

/**
*	c[x]
*															1000
*							   /â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”[8]
*							  /								 |
*							100								 |
*			   /â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”[4]				   /â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”[ ]
*			  /				 |				  /				 |
*			010				 |				110				 |
*	   /â€”â€”â€”â€”[2]		   /â€”â€”â€”â€”[ ]		   /â€”â€”â€”â€”[6]		   /â€”â€”â€”â€”[ ]
*	  /		 |		  /		 |		  /		 |		  /		 |
*	001		 |		011		 |		101		 |		111		 |
*	[1]		[ ]		[3]		[ ]		[5]		[ ]		[7]		[ ]
*/
int c[50005];//æ ‘çŠ¶æ•°ç»„,ä»1å¼€å§‹
// c[i] = data[i - 2 ^ k + 1 ... i];

int data[50005];//å­˜å‚¨åŸå§‹æ•°æ®,ä»1å¼€å§‹

int s[50005];//å‰ç¼€æ•°ç»„,åœ¨initæ—¶ç”¨åˆ°,ä»1å¼€å§‹

int T, N, a, b;

int calSum(int where) {//è¿”å›ä»data[1...where]
	int su = 0;
	while (where) {
		su += c[where];
		where -= lowbit(where);
	}
	return su;
}

void add(int where, int what) {
	while (where &lt;= N) {
		c[where] += what;
		where += lowbit(where);
	}
}

int init() {
	int sum = 0;
	// for (int i = 1; i &lt;= N; i++) {
	// 	for (int x = i - lowbit(i) + 1; x &lt;= i; x++) {
	// 		c[i] += data[x];
	// 	}
	// }
	// ç”¨å‰ç¼€æ•°ç»„æ¥è¿›è¡Œä¼˜åŒ–ï¼š
	for (int i = 1; i &lt;= N; i++) {
		c[i] = s[i] - s[i - lowbit(i)];
	}

}

int main(int argc, char const *argv[])
{

	char cmd[10];
	scanf(&#34;%d&#34;, &amp;T);

	for (int t = 1; t &lt;= T; t++) {

		memset(c, 0, sizeof(c));
		memset(data, 0, sizeof(data));
		memset(s, 0, sizeof(s));

		scanf(&#34;%d&#34;, &amp;N);

		for (int i = 1; i &lt;= N; i++) {
			scanf(&#34;%d&#34;, data + i);
			s[i] = s[i - 1] + data[i];
		}

		init();

		printf(&#34;Case %d:\n&#34;, t);
		for (;;) {
			scanf(&#34;%s&#34;, cmd);
			if (&#39;E&#39; == cmd[0]) {
				break;
			}
			scanf(&#34;%d%d&#34;, &amp;a, &amp;b);
			switch (cmd[0]) {
			case &#39;Q&#39;:
				printf(&#34;%d\n&#34;, calSum(b) - calSum(a - 1));
				break;
			case &#39;A&#39;:
				add(a, b);
				break;
			case &#39;S&#39;:
				add(a, -b);
				break;
			}
		}
	}

	return 0;
}
</code></pre></main><div id=comments><hr><script src=//geoip-js.com/js/apis/geoip2/v2.1/geoip2.js type=text/javascript></script><script>var onSuccess=function(e){var t=e.country.names["zh-CN"],n=e.country.iso_code;if(!n)return;t&&(document.getElementById("comments-blocked-country-code").innerHTML=t),n=="CN"&&(document.getElementById("comments-shown").style.display="none",document.getElementById("comments-blocked").style.display="")},onError=function(){};geoip2.country(onSuccess,onError)</script><div id=comments-blocked style=font-style:italic;color:#777;display:none>è¯„è®ºåŒºå·²å…³é—­ã€‚<span style=float:right>æ¥è‡ª <span id=comments-blocked-country-code>unknown</span> çš„è®¿å®¢
<span>&nbsp; - powered by: geoip-js.com</span></span></div><div id=comments-shown><script src=https://utteranc.es/client.js repo=imlk0/imlk0.github.io issue-term=pathname label='ğŸ’¬ comments ğŸ’¬' theme=github-light crossorigin=anonymous async></script></div></div><footer class=footer><hr>Â© imlk 2017 &ndash; 2023 | <a href=https://blog.imlk.top>imlk's blog</a> | <a href=https://github.com/imlk0/>Github</a> | <a href=mailto:me@imlk.top>Email</a> | <a href=https://beian.miit.gov.cn/>äº¬ICPå¤‡2020042968å·-1</a></footer></body></html>