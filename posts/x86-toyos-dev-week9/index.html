<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>自制x86玩具操作系统 week9 | imlk's blog</title>
<link rel=stylesheet href=/css/style.css><link rel=stylesheet href=/css/fonts.css><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@400;700&display=swap" rel=stylesheet></head><body><header class=header><a class=logo href=/>imlk's Blog</a><nav><ul class=menu><li><a href=/>🏠Home</a></li><li><a href=/about/>👋About</a></li><li><a href=/archives/>📜Archives</a></li><li><a href=/friends/>🔗Friends</a></li><li><a href=/dn42/>🕸️DN42</a></li><li><a href=/index.xml>📢Subscribe</a></li></ul></nav></header><hr><div class=article-meta><h1><span class=title>自制x86玩具操作系统 week9</span></h1><span><span class=date>📅 2019-05-01</span>
<span class=date>(更新于2021-10-10)</span>
/
<span class=cats>📚
<a href=https://blog.imlk.top/categories/osdev/>OSDev</a>
</span>/
<span class=tags>🏷️
<a href=https://blog.imlk.top/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/>#操作系统</a>
<a href=https://blog.imlk.top/tags/diy/>#DIY</a></span></span><br></div><main class=post-content><h2 id=day-0x18>DAY 0x18</h2><h4 id=分页前的准备>分页前的准备</h4><p>Linux并没有非常依赖于段表，而是采用的分页结构，将内核和用户程序的段设置为覆盖整个内存区域以此来绕过分段结构，但是显然这个30天操作系统的作者并不打算这样做，它把内核数据段设置为整个内存区域，但是却把代码段设置成0x00280000开始的空间。这对于之后加入类似于Linux的分页模式造成了不便，首先我们想办法把内核数据段改为覆盖整个内存区。</p><p>先看一下内存区域图：</p><pre tabindex=0><code>|-------------------------------------------------------|0x00280000
|	512KB	0x00080000Byte								|
|	bootpack.hrb内容被asmhead.nas整体加载到此区域执行		|0x002fffff
|-------------------------------------------------------|0x00300000
|	64KB	0x00010000Byte								|
|	内核栈												|0x0030ffff
|-------------------------------------------------------|0x00310000
|	960KB	0x000f0000Byte								|
|	bootpack.hrb中的数据区域								|
|	0x003c0000存放了MEMMAN(大小大约0x8000Byte)				|0x003fffff
|-------------------------------------------------------|0x00400000(4M)
</code></pre><p>作者将bootpack.hrb放到了0x00280000处，然后通过farjmp指令<code>JMP DWORD 2*8:0x0000001b</code>（注意作者的第二个段的base是0x00280000），跳到bootpack.hrb的头部的一个写有jmp指令的跳板（一个根据相对pc的偏移量跳转的jmp指令）,然后继续跳入bootpack.hrb的代码段。</p><p>那么我们首先要解决逻辑地址的问题，原先bootpack.hrb逻辑地址是从0开始的，但是现在我们把第二个段的base从0x00280000改到0，相应的逻辑地址应该加上0x00280000，结合之前分析作者的obj2bim和bim2hrb的逻辑知道，在.rul文件中可以修改链接时代码段的逻辑基地址，我们这里在原来的基础上加上0x00280000，asmhead.nas中的临时段表和dsctbl.cpp根据段表的结构相应的改成覆盖全部内存区域</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>	set_segmdesc(gdt <span style=color:#f92672>+</span> ((<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span>)__KERNEL_DS <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>3</span>), <span style=color:#ae81ff>0xffffffff</span>, <span style=color:#ae81ff>0x00000000</span>, AR_DATA32_RW);
</span></span><span style=display:flex><span>	set_segmdesc(gdt <span style=color:#f92672>+</span> ((<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span>)__KERNEL_CS <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>3</span>), <span style=color:#ae81ff>0xffffffff</span>, <span style=color:#ae81ff>0x00000000</span>, AR_CODE32_ER);
</span></span></code></pre></div><pre tabindex=0><code class=language-assembly data-lang=assembly>		; limit 0xffffffff base:0x00000000 ar:0xc092 
		DW		0xffff,0x0000,0x9200,0x00cf
		; limit 0xffffffff base:0x00000000 ar:0x409a
		DW		0xffff,0x0000,0x9a00,0x00cf
</code></pre><p>然后这里要将bootpack.hrb的头部的跳板jmp指令进行修改，在内存中先将jmp指令的偏移量减去0x00280000再set回去</p><pre tabindex=0><code class=language-assembly data-lang=assembly>		MOV		EBX,0x0028001c
		MOV		EAX,[EBX]
		SUB		EAX,0x00280000
		MOV		[EBX],EAX
		JMP		DWORD 2*8:0x0028001b
</code></pre><p>效果如下，能够成功启动，但是执行用户程序hello的时候有一点问题，显然是因为我们动了.rul文件的原因，得把用户程序链接用的.rul文件和和内核程序的分开来
<img src=/images/blog/os/17.png alt></p><h4 id=内核代码二级分页>内核代码二级分页</h4><h5 id=准备>准备</h5><p>这是网上找的Linux的线性地址到物理地址映射的图
<img src=/images/blog/os/16.png alt></p><p>我们这里准备在内核中先做两个映射</p><ul><li>这部分512MB空间直接通过偏移量的方式给内核程序用
0xc0000000-0xdfffffff -> 0x000000000000-0x00001fffffff</li><li>这部分最高的512MB空间由于开启了VBE画面模式，图像缓冲存在这里，因此避免麻烦我们直接映射
0xe0000000-0xffffffff -> 0x0000e0000000-0x0000ffffffff</li></ul><h5 id=调逻辑地址>调逻辑地址</h5><p>首先，我们要再次调整逻辑地址，这次调整的是bootpack数据段（包括栈区域）和bootpack代码段的地址，在.rul文件中改成这样</p><pre tabindex=0><code>	code(align:1, logic:0xC0280024,      file:0x24);
	data(align:4, logic:0xC0310000, file:code_end);
</code></pre><p>asmhead中加载bootpack的地址要做一些修改使它保持在原来的地方，之后我们分页开启后用高逻辑地址来进行访问这部分低物理地址空间
然后就是在jmp到bootpack之前，用汇编来填充我们的页目录和页表了</p><h5 id=写入页表>写入页表</h5><p>页目录项的结构
<img src=/images/blog/os/15.png alt>
页表项的结构
<img src=/images/blog/os/18.png alt>
要注意的是，页目录项中存储的地址应该是页表的物理地址而不是页表的线性地址。</p><p>线性地址中10位对应页目录项索引，10位对应页表项索引，一个页目录项和一个页表项的大小都是4字节，所以一张页目录大小和一张页表大小都是<code>4*2^10B = 4KB</code>，也就是要占用掉0x1000大小的地址空间。
我们将<code>0x00400000</code>作为页目录起始位置，页目录之后放置页表
这些表一共耗费了<code>1GB/4KB*4+4KB=1MB+4KB</code>的空间，分配了高1G的线性地址，低位的地址在进入bootpack后再进行动态分配。</p><h5 id=启用页表>启用页表</h5><p>让CR3存储页目录的物理地址，再在R0中设置pg标志位为1。由于x86默认是二级页表，如果想启用其他类型的页表需要先给CR4寄存器的某些位赋值。
开启页表后出现的一个问题是，由于CPU取指也依赖于段表和页表这两级的地址转换。
在执行<code>MOV CR0,EAX</code>后，我们的代码只能用线性地址来访问了，但是现在我们的EIP寄存器中的依然是物理地址（之所以是物理地址是因为我们已经绕过了段表），在我们的设计中，bootpack的线性地址和物理地址是不同的。</p><p>为解决这个问题，我们将计就计，在内存的高物理地址区（和bootpack的线性地址数值上相同的那里，写入<code>MOV CR0,EAX</code>这条开启分页的指令的机器码(仅3个字节)，然后从asmhead里面jmp到这个地方执行。</p><pre tabindex=0><code>(0) [0x0000c0280000] 0010:00000000c0280000 (unk. ctxt): mov cr0, eax              ; 0f22c0
</code></pre><p>执行完这条指令后分页已经开启，EIP采用线性地址，经过页表的转换，实际上执行的代码落在了内存的低物理地址区域里，也就是我们加载的bootpack代码入口<code>0x00280003</code>处。</p><pre tabindex=0><code>&lt;bochs:4&gt; n
Next at t=34870451
(0) [0x000000280003] 0010:00000000c0280003 (unk. ctxt): nop                       ; 90
</code></pre><p>为了方便编写，加载bootpack后，把前头部前0x1b个字节全部改写成nop指令，这样在高地址开启分页后，下一条指令会落回在一堆nop指令组成的“滑板”上，一直滑到bootpack开头0x1b处的那个jmp指令那里，最终会成功舶入bootpack.cpp的HariMain函数。</p><p>通过在HariMain函数的开始加上一条bochsdbg()语句断点来进行验证
<img src=/images/blog/os/19.png alt></p><h5 id=修改c层代码>修改c层代码</h5><p>进入bootpack只是开启分页之后的第一步，现在的c层代码是不能使用的，直接continue会立刻崩掉，原因有好几个：</p><ul><li>代码中硬编码了太多的低地址，像binfo什么的，还有作者随便拿来存储变量的一部分低地址，都要加上一个偏移量，可以用宏的方式来实现</li><li>memtest函数的范围问题</li><li>load_gdtr和load_idtr的地址问题（一开始以为得加载物理地址），后面总是莫名其妙页错误，然后发现开启分页以后去load的话应该load线性地址</li><li>代码不规范存在取用null指针的bug，我们还没有映射低地址区域所以会直接页错误PE</li><li>TASK结构体里面的cr3字段要处理</li></ul><p>注意几点：</p><ul><li>页错误的中断号是0x0e</li><li>改完bug前先不要允许任何中断，否则可能在发生中断时突然crash，导致在调试时会把正确的代码误以为是错误的</li><li>结合.map文件和静态分析工具分析错误位置</li></ul><p><img src=/images/blog/os/20.png alt></p><p>用户态分页表需要为每一个task建立一个页目录，在task切换的时候赋值cr3，时间关系我们下周再做这个了。</p></main><div id=comments><hr><script src=//geoip-js.com/js/apis/geoip2/v2.1/geoip2.js type=text/javascript></script><script>var onSuccess=function(e){var t=e.country.names["zh-CN"],n=e.country.iso_code;if(!n)return;t&&(document.getElementById("comments-blocked-country-code").innerHTML=t),n=="CN"&&(document.getElementById("comments-shown").style.display="none",document.getElementById("comments-blocked").style.display="")},onError=function(){};geoip2.country(onSuccess,onError)</script><div id=comments-blocked style=font-style:italic;color:#777;display:none>评论区已关闭。<span style=float:right>来自 <span id=comments-blocked-country-code>unknown</span> 的访客
<span>&nbsp; - powered by: geoip-js.com</span></span></div><div id=comments-shown><script src=https://utteranc.es/client.js repo=KB5201314/KB5201314.github.io issue-term=pathname label='💬 comments 💬' theme=github-light crossorigin=anonymous async></script></div></div><footer class=footer><hr>© imlk 2017 &ndash; 2023 | <a href=https://blog.imlk.top>imlk's blog</a> | <a href=https://github.com/KB5201314/>Github</a> | <a href=mailto:me@imlk.top>Email</a> | <a href=https://beian.miit.gov.cn/>京ICP备2020042968号-1</a></footer></body></html>