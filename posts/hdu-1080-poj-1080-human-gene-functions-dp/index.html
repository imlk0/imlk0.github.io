<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>HDU 1080 POJ 1080 Human Gene Functions——动态规划 | imlk's blog</title>
<link rel=stylesheet href=/css/style.css><link rel=stylesheet href=/css/fonts.css><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@400;700&display=swap" rel=stylesheet></head><body><header class=header><a class=logo href=/>imlk's Blog</a><nav><ul class=menu><li><a href=/>🏠Home</a></li><li><a href=/about/>👋About</a></li><li><a href=/archives/>📜Archives</a></li><li><a href=/friends/>🔗Friends</a></li><li><a href=/dn42/>🕸️DN42</a></li><li><a href=/index.xml>📢Subscribe</a></li></ul></nav></header><hr><div class=article-meta><h1><span class=title>HDU 1080 POJ 1080 Human Gene Functions——动态规划</span></h1><span><span class=date>📅 2018-02-26</span>
<span class=date>(更新于2021-10-10)</span>
/
<span class=cats>📚
<a href=https://blog.imlk.top/categories/algorithm/>Algorithm</a>
</span>/
<span class=tags>🏷️
<a href=https://blog.imlk.top/tags/poj/>#POJ</a></span></span><br></div><main class=post-content><p><a href="http://poj.org/problem?id=1080">http://poj.org/problem?id=1080</a>
<a href="http://acm.hdu.edu.cn/showproblem.php?pid=1080">http://acm.hdu.edu.cn/showproblem.php?pid=1080</a></p><pre tabindex=0><code>#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;map&gt;
#include &lt;cstring&gt;

#define MAX(x,y,z) ((x)&gt;(y)?((x)&gt;(z)?(x):(z)):((y)&gt;(z)?(y):(z)))

using namespace std;

char str1[105];
char str2[105];
int list[6][6] = {
//	  		{ \0,  A,  C,  G,  T,  -}
	/*\0*/	{  0,  0,  0,  0,  0,  0},
	/*A*/	{  0,  5, -1, -2, -1, -3},
	/*C*/	{  0, -1,  5, -3, -2, -4},
	/*G*/	{  0, -2, -3,  5, -2, -2},
	/*T*/	{  0, -1, -2, -2,  5, -1},
	/*-*/	{  0, -3, -4, -2, -1,  0},
};
map&lt;char, int&gt;m;

int dp[105][105];//dp[x][y]表示str1中1...x-1个字符和str2中第1...y-1之间匹配的最优解

int main(int argc, char const *argv[])
{
	int T, len1, len2;
	scanf(&#34;%d&#34;, &amp;T);

	m[&#39;\0&#39;] = 0;
	m[&#39;A&#39;] = 1;
	m[&#39;C&#39;] = 2;
	m[&#39;G&#39;] = 3;
	m[&#39;T&#39;] = 4;
	m[&#39;-&#39;] = 5;

	while (T--) {
		memset(dp, 0, sizeof(dp));
		scanf(&#34;%d%s&#34;, &amp;len1, str1 + 1);
		scanf(&#34;%d%s&#34;, &amp;len2, str2 + 1);

		// printf(&#34;\t\t&#34;);
		// for (int y = 0; y &lt; len2; y++) {
		// 	printf(&#34;%c\t&#34;, s2[y]);
		// }
		// printf(&#34;\n\t&#34;);

		// for (int y = 0; y &lt;= len2; y++) {
		// 	printf(&#34;%d\t&#34;, dp[0][y]);

		// }
		// printf(&#34;\n&#34;);

		for (int x = 1; x &lt;= len1 + 1; x++) {
			dp[x][0] = -1e9;
		}

		for (int y = 1; y &lt;= len2 + 1; y++) {
			dp[0][y] = -1e9;
		}

		for (int x = 1; x &lt;= len1 + 1; x++) {

			for (int y = 1; y &lt;= len2 + 1; y++) {
				dp[x][y] = MAX(
				               dp[x - 1][y - 1] + list[m[str1[x - 1]]][m[str2[y - 1]]],
				               dp[x - 1][y] + list[m[str1[x - 1]]][m[&#39;-&#39;]],
				               dp[x][y - 1] + list[m[&#39;-&#39;]][m[str2[y - 1]]]
				           );

//取消注釋打印流程

/*				if (dp[x - 1][y - 1] + list[m[str1[x - 1]]][m[str2[y - 1]]]
				        &gt;= dp[x - 1][y] + list[m[str1[x - 1]]][m[&#39;-&#39;]]) {
					if (dp[x - 1][y - 1] + list[m[str1[x - 1]]][m[str2[y - 1]]]
					        &gt;=
					        dp[x][y - 1] + list[m[&#39;-&#39;]][m[str2[y - 1]]]) {
						printf(&#34;↖%d\t&#34;, dp[x][y]);
					} else {
						printf(&#34;←%d\t&#34;, dp[x][y]);
					}
				} else {
					if (dp[x - 1][y] + list[m[str1[x - 1]]][m[&#39;-&#39;]]
					        &gt;=
					        dp[x][y - 1] + list[m[&#39;-&#39;]][m[str2[y - 1]]]) {
						printf(&#34;↑%d\t&#34;, dp[x][y]);
					} else {
						printf(&#34;←%d\t&#34;, dp[x][y]);

					}
				}
*/

			}

/*
			printf(&#34;\n&#34;);
*/

		}
		printf(&#34;%d\n&#34;, dp[len1 + 1][len2 + 1]);

		/**
		*
		*	in:
		*	
		*	2
		*	7 AGTGATG
		*	5 GTTAG
		*	7 AGCTATT
		*	9 AGCTTTAAA
		*	
		*	out:
		*	
		*	↖0		←-2		←-3		←-4		←-7		←-9
		*	↑-3		↖-2		↖-3		↖-4		↖1		←-1
		*	↑-5		↖2		←1		←0		↑-1		↖6
		*	↑-6		↑1		↖7		↖6		←3		↑5
		*	↑-8		↖-1		↑5		↖5		↖4		↖8
		*	↑-11	↑-4		↑2		↖4		↖10		←8
		*	↑-12	↑-5		↖1		↖7		↑9		↖8
		*	↑-14	↖-7		↑-1		↑5		↑7		↖14
		*	
		*	14
		*	
		*	↖0		←-3		←-5		←-9		←-10	←-11	←-12	←-15	←-18	←-21
		*	↑-3		↖5		←3		←-1		←-2		←-3		←-4		↖-7		↖-10	↖-13
		*	↑-5		↑3		↖10		←6		←5		←4		←3		←0		←-3		←-6
		*	↑-9		↑-1		↑6		↖15		←14		←13		←12		←9		←6		←3
		*	↑-10	↑-2		↑5		↑14		↖20		↖19		↖18		←15		←12		←9
		*	↑-13	↖-5		↑2		↑11		↑17		↖19		↖18		↖23		↖20		↖17
		*	↑-14	↑-6		↑1		↑10		↖16		↖22		↖24		↑22		↖22		↖19
		*	↑-15	↑-7		↑0		↑9		↖15		↖21		↖27		←24		↖21		↖21
		*	
		*	
		*	21
		*	
		*	
		*	
		*/

	}
	return 0;
}
</code></pre><p>后来发现是自己想得太多了，这个题的“状态”不一定非要理解成原先那样，
其实完全可以也像最大公共子列那样的，
dp[x][y]表示str1的前x个字符和str2的前y个字符之间的匹配结果的最优解
这样也便于理解，便于思考</p><p>这样的话dp[x][y]就是最终答案，不过要注意边界的预处理
代码如下</p><pre tabindex=0><code>#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;map&gt;
#include &lt;cstring&gt;

#define MAX(x,y,z) ((x)&gt;(y)?((x)&gt;(z)?(x):(z)):((y)&gt;(z)?(y):(z)))

using namespace std;

char str1[105];
char str2[105];
int list[6][6] = {
//	  		{  A,  C,  G,  T,  -}
	/*A*/	{  5, -1, -2, -1, -3},
	/*C*/	{ -1,  5, -3, -2, -4},
	/*G*/	{ -2, -3,  5, -2, -2},
	/*T*/	{ -1, -2, -2,  5, -1},
	/*-*/	{ -3, -4, -2, -1,  0},
};

map&lt;char, int&gt;m;

int dp[105][105];//dp[x][y]表示str1中1...x个字符和str2中第1...y这两个子串之间的所有匹配方式的最大利益

int main(int argc, char const *argv[])
{
	int T, len1, len2;
	scanf(&#34;%d&#34;, &amp;T);

	m[&#39;A&#39;] = 0;
	m[&#39;C&#39;] = 1;
	m[&#39;G&#39;] = 2;
	m[&#39;T&#39;] = 3;
	m[&#39;-&#39;] = 4;

	while (T--) {
		memset(dp, 0, sizeof(dp));
		scanf(&#34;%d%s&#34;, &amp;len1, str1 + 1);
		scanf(&#34;%d%s&#34;, &amp;len2, str2 + 1);

		// printf(&#34;\t\t&#34;);
		// for (int y = 0; y &lt; len2; y++) {
		// 	printf(&#34;%c\t&#34;, s2[y]);
		// }
		// printf(&#34;\n\t&#34;);

		// for (int y = 0; y &lt;= len2; y++) {
		// 	printf(&#34;%d\t&#34;, dp[0][y]);

		// }
		// printf(&#34;\n&#34;);

		for (int x = 1; x &lt;= len1; x++) {
			dp[x][0] = dp[x - 1][0] + list[m[str1[x]]][m[&#39;-&#39;]];
		}

		// printf(&#34;↖0\t&#34;);
		for (int y = 1; y &lt;= len2; y++) {
			dp[0][y] = dp[0][y - 1] + list[m[str2[y]]][m[&#39;-&#39;]];
			// printf(&#34;←%d\t&#34;, dp[0][y]);
		}
		// printf(&#34;\n&#34;);

		for (int x = 1; x &lt;= len1; x++) {

			// printf(&#34;↑%d\t&#34;, dp[x][0]);

			for (int y = 1; y &lt;= len2; y++) {
				dp[x][y] = MAX(
				               dp[x - 1][y - 1] + list[m[str1[x]]][m[str2[y]]],
				               dp[x - 1][y] + list[m[str1[x]]][m[&#39;-&#39;]],
				               dp[x][y - 1] + list[m[&#39;-&#39;]][m[str2[y]]]
				           );

//取消所有额外注释可打印流程
				/*
								if (dp[x - 1][y - 1] + list[m[str1[x]]][m[str2[y]]]
								        &gt;= dp[x - 1][y] + list[m[str1[x]]][m[&#39;-&#39;]]) {
									if (dp[x - 1][y - 1] + list[m[str1[x]]][m[str2[y]]]
									        &gt;=
									        dp[x][y - 1] + list[m[&#39;-&#39;]][m[str2[y]]]) {
										printf(&#34;↖%d\t&#34;, dp[x][y]);
									} else {
										printf(&#34;←%d\t&#34;, dp[x][y]);
									}
								} else {
									if (dp[x - 1][y] + list[m[str1[x]]][m[&#39;-&#39;]]
									        &gt;=
									        dp[x][y - 1] + list[m[&#39;-&#39;]][m[str2[y]]]) {
										printf(&#34;↑%d\t&#34;, dp[x][y]);
									} else {
										printf(&#34;←%d\t&#34;, dp[x][y]);

									}
								}
				*/

			}

			/*
						printf(&#34;\n&#34;);
			*/

		}
		printf(&#34;%d\n&#34;, dp[len1][len2]);

		/**
		*
		*	in:
		*
		*	2
		*	7 AGTGATG
		*	5 GTTAG
		*	7 AGCTATT
		*	9 AGCTTTAAA
		*
		*	out:
		*
		*	↖0		←-2		←-3		←-4		←-7		←-9
		*	↑-3		↖-2		↖-3		↖-4		↖1		←-1
		*	↑-5		↖2		←1		←0		↑-1		↖6
		*	↑-6		↑1		↖7		↖6		←3		↑5
		*	↑-8		↖-1		↑5		↖5		↖4		↖8
		*	↑-11	↑-4		↑2		↖4		↖10		←8
		*	↑-12	↑-5		↖1		↖7		↑9		↖8
		*	↑-14	↖-7		↑-1		↑5		↑7		↖14
		*
		*	14
		*
		*	↖0		←-3		←-5		←-9		←-10	←-11	←-12	←-15	←-18	←-21
		*	↑-3		↖5		←3		←-1		←-2		←-3		←-4		↖-7		↖-10	↖-13
		*	↑-5		↑3		↖10		←6		←5		←4		←3		←0		←-3		←-6
		*	↑-9		↑-1		↑6		↖15		←14		←13		←12		←9		←6		←3
		*	↑-10	↑-2		↑5		↑14		↖20		↖19		↖18		←15		←12		←9
		*	↑-13	↖-5		↑2		↑11		↑17		↖19		↖18		↖23		↖20		↖17
		*	↑-14	↑-6		↑1		↑10		↖16		↖22		↖24		↑22		↖22		↖19
		*	↑-15	↑-7		↑0		↑9		↖15		↖21		↖27		←24		↖21		↖21
		*
		*
		*	21
		*
		*
		*
		*/

	}
	return 0;
}
</code></pre></main><div id=comments><hr><script src=//geoip-js.com/js/apis/geoip2/v2.1/geoip2.js type=text/javascript></script><script>var onSuccess=function(e){var t=e.country.names["zh-CN"],n=e.country.iso_code;if(!n)return;t&&(document.getElementById("comments-blocked-country-code").innerHTML=t),n=="CN"&&(document.getElementById("comments-shown").style.display="none",document.getElementById("comments-blocked").style.display="")},onError=function(){};geoip2.country(onSuccess,onError)</script><div id=comments-blocked style=font-style:italic;color:#777;display:none>评论区已关闭。<span style=float:right>来自 <span id=comments-blocked-country-code>unknown</span> 的访客
<span>&nbsp; - powered by: geoip-js.com</span></span></div><div id=comments-shown><script src=https://utteranc.es/client.js repo=imlk0/imlk0.github.io issue-term=pathname label='💬 comments 💬' theme=github-light crossorigin=anonymous async></script></div></div><footer class=footer><hr>© imlk 2017 &ndash; 2023 | <a href=https://blog.imlk.top>imlk's blog</a> | <a href=https://github.com/imlk0/>Github</a> | <a href=mailto:me@imlk.top>Email</a> | <a href=https://beian.miit.gov.cn/>京ICP备2020042968号-1</a></footer></body></html>