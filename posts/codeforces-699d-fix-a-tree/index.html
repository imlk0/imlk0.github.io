<!DOCTYPE html>
<html lang="zh-cn">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>CodeForces 699D Fix a Tree | imlk&#39;s blog</title>
  <link rel="stylesheet" href='/css/style.css' />
  <link rel="stylesheet" href='/css/fonts.css' />
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@400;700&display=swap" rel="stylesheet">
</head>

<body>
  <header class="header">
    <a class="logo" href='/'> imlk's Blog </a>
    <nav>
      <ul class="menu">
        
        <li><a href="/">Home</a></li>
        
        <li><a href="/about/">About</a></li>
        
        <li><a href="/archives/">Archives</a></li>
        
        <li><a href="/friends/">Friends</a></li>
        
        <li><a href="/index.xml">Subscribe</a></li>
        
      </ul>
    </nav>
  </header>
  <hr />



<div class="article-meta">
    <h1><span class="title">CodeForces 699D Fix a Tree</span></h1>
    
    <span>
        <span class="date">2018-02-08</span>
        |
        
        <span class="cats">
            
            
            <a href='https://blog.imlk.top/categories/algorithm/'>Algorithm</a>
            
        </span>
        
        |
        <span class="tags">
            
            <a href='https://blog.imlk.top/tags/codeforces/'>#Codeforces</a>
            
            <a href='https://blog.imlk.top/tags/tree/'>#Tree</a>
            
        </span>
        
    </span>
    <br>
    
</div>


<main>
    <p>å¹¶æŸ¥é›†ä¼˜åŒ– ç»™å‡ºæ‰€æœ‰èŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹ï¼ˆæœ‰å‘å›¾ï¼‰ï¼Œç”¨æœ€å°‘çš„ä¿®æ”¹ç”Ÿæˆä¸€é¢—åˆæ³•çš„æ ‘ï¼ˆç¯çš„åˆ¤æ–­ï¼Œå»ç¯ï¼‰</p>
<pre tabindex="0"><code>D. Fix a Tree
time limit per test
2 seconds
memory limit per test
256 megabytes
input
standard input
output
standard output

A tree is an undirected connected graph without cycles.

Let's consider a rooted undirected tree with n vertices, numbered 1 through n. There are many ways to represent such a tree. One way is to create an array with n integers p1,â€‰p2,â€‰...,â€‰pn, where pi denotes a parent of vertex i (here, for convenience a root is considered its own parent).
For this rooted tree the array p is [2,â€‰3,â€‰3,â€‰2].

Given a sequence p1,â€‰p2,â€‰...,â€‰pn, one is able to restore a tree:

    There must be exactly one index r that prâ€‰=â€‰r. A vertex r is a root of the tree.
    For all other nâ€‰-â€‰1 vertices i, there is an edge between vertex i and vertex pi. 

A sequence p1,â€‰p2,â€‰...,â€‰pn is called valid if the described procedure generates some (any) rooted tree. For example, for nâ€‰=â€‰3 sequences (1,2,2), (2,3,1) and (2,1,3) are not valid.

You are given a sequence a1,â€‰a2,â€‰...,â€‰an, not necessarily valid. Your task is to change the minimum number of elements, in order to get a valid sequence. Print the minimum number of changes and an example of a valid sequence after that number of changes. If there are many valid sequences achievable in the minimum number of changes, print any of them.
Input

The first line of the input contains an integer n (2â€‰â‰¤â€‰nâ€‰â‰¤â€‰200â€‰000) â€” the number of vertices in the tree.

The second line contains n integers a1,â€‰a2,â€‰...,â€‰an (1â€‰â‰¤â€‰aiâ€‰â‰¤â€‰n).
Output

In the first line print the minimum number of elements to change, in order to get a valid sequence.

In the second line, print any valid sequence possible to get from (a1,â€‰a2,â€‰...,â€‰an) in the minimum number of changes. If there are many such sequences, any of them will be accepted.
Examples
Input

4
2 3 3 4

Output

1
2 3 4 4 

Input

5
3 2 2 5 3

Output

0
3 2 2 5 3 

Input

8
2 3 5 4 1 6 6 7

Output

2
2 3 7 8 1 6 6 7
</code></pre><p>##<strong>0x00</strong></p>
<p><strong>è¿™é¢˜æˆ‘çš„ç¬¬ä¸€ç§è§£æ³•å°±æ˜¯å…ˆå°†å¤šä¸ªæ ‘åˆå¹¶åˆ°ä¸€èµ·ï¼Œç„¶åéå†æ¯ä¸€ä¸ªèŠ‚ç‚¹ï¼Œæš´åŠ›æœå¯»ç¯ï¼Œç±»ä¼¼dfsï¼Œä¸æ–­å‘çˆ¶å…ƒç´ é€’è¿›ï¼Œç”¨ä¸€ä¸ªsetå‚¨å­˜é€”ç»çš„æ‰€æœ‰å…ƒç´ ï¼Œå¯¹äºæŸ¥æ‰¾åˆ°èŠ‚ç‚¹iæ—¶ï¼Œåˆ¤æ–­å®ƒçš„çˆ¶å…ƒç´ åœ¨setä¸­æ˜¯å¦å‡ºç°äº†ï¼Œå¦‚æœå‡ºç°äº†å°±è¯´æ˜æˆäº†ç¯ï¼Œç„¶åè®¾ç½®èŠ‚ç‚¹içš„çˆ¶èŠ‚ç‚¹ä¸ºä¸€ä¸ªç»Ÿä¸€çš„æ ¹èŠ‚ç‚¹
ä¸ºäº†ä¼˜åŒ–é€Ÿåº¦ï¼Œå¼•å…¥ä¸€ä¸ªvisitedæ•°ç»„è®°å½•æŸä¸ªèŠ‚ç‚¹æ˜¯å¦å·²ç»è®¿é—®è¿‡ï¼Œå¦‚æœè®¿é—®è¿‡é‚£ä¹ˆä¸‹ä¸€æ¬¡é‡åˆ°çš„æ—¶å€™å°±ç›´æ¥ç»“æŸå‘çˆ¶å…ƒç´ çš„é€’è¿›</strong></p>
<pre tabindex="0"><code>#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;cmath&gt;
#include &lt;set&gt;

using namespace std;

// AC
//200ms

set&lt;int&gt; line;//ç¼“å­˜æŸ¥æ‰¾è¿‡ç¨‹ä¸­ç»è¿‡çš„æ‰€æœ‰å…ƒç´ ,è€—æ—¶é«˜

int n, changes = 0;
int root = 0;

int fa[200005];//è¿™ä¸ªæ•°ç»„ä½œä¸ºæœ€åçš„è¾“å‡ºç»“æœ
int visited[200005];//ä¼˜åŒ–

void check(int i) {//æ£€æŸ¥æ˜¯å¦æœ‰ç¯å‡ºç°

	if (!line.empty()) {
		line.clear();
	}

	while (fa[i] != i) {//æœªåˆ°è¾¾æ ‘é¡¶ç«¯æ—¶ä¸æ–­å¾ªç¯

		visited[i] = 1;

		if (line.count(fa[i])) {//è‹¥æ‰¾åˆ°ç¯
			changes++;//æ”¹å˜æ¬¡æ•°+1
			if (!root) {//è‹¥è¿˜æ²¡æœ‰æ ¹å…ƒç´ 
				root = i;// å°†æ­¤æ—¶çš„iä½œä¸ºæ ¹å…ƒç´ 
			}

			fa[i] = root;//æŠŠå½“å‰å…ƒç´ æŒ‚åˆ°æ ¹å…ƒç´ ä¸‹

			return;//é€€å‡ºå¾ªç¯

		} else {//è‹¥è¿™ä¸€æ­¥ä¹Ÿæ²¡å‡ºç°ç¯
			line.insert(i);//æŠŠå½“å‰å…ƒç´ åŠ åˆ°setä¸­
			i = fa[i];// è¿­ä»£
			if (visited[i]) { //è‹¥å·²ç»æ‹œè®¿è¿‡äº†,å°±ç›´æ¥é€€å‡ºï¼Œè¿™ä¸€æ­¥ä¼˜åŒ–å¾ˆå…³é”®ï¼
				return;
			}
		}

	}

}

int main(int argc, char const *argv[])
{
	scanf(&quot;%d&quot;, &amp;n);

	for (int i = 1; i &lt;= n; ++i) {
		scanf(&quot;%d&quot;, fa + i);
		if (fa[i] == i) {
			if (root) { //è‹¥æ­¤å‰å·²ç»æœ‰æ ¹èŠ‚ç‚¹
				fa[i] = root;
				changes++;
			} else {
				root = i;
			}
		}
	}

	for (int i = 1; i &lt;= n; ++i) {
		if (!visited[i]) {
			check(i);
		}
	}

	printf(&quot;%d\n&quot;, changes);

	printf(&quot;%d&quot;, fa[1]);

	for (int i = 2; i &lt;= n; ++i) {
		printf(&quot; %d&quot;, fa[i]);
	}

	printf(&quot;\n&quot;);
	return 0;
}
</code></pre><p>##<strong>0x01</strong>
<strong>æˆ‘çš„ç¬¬äºŒç§è§£æ³•æ˜¯ç»“åˆå¹¶æŸ¥é›†</strong></p>
<p><strong>æ€è€ƒ
å¦‚æœå°†ä¸€ä¸ªæ ‘ä¸­çš„æŸä¸ªèŠ‚ç‚¹içš„çˆ¶èŠ‚ç‚¹è®¾ç½®ä¸ºæŸä¸ªèŠ‚ç‚¹jï¼Œå¯¼è‡´å‡ºç°äº†ç¯ï¼Œé‚£ä¹ˆæ˜¾ç„¶ä»jæ²¿ç€çˆ¶èŠ‚ç‚¹çš„æ–¹å‘å»é€’æ¨ï¼ˆç”¨å¹¶æŸ¥é›†çš„findå‡½æ•°ï¼‰ï¼Œæœ€ç»ˆä¸€å®šä¼šåˆ°è¾¾ièŠ‚ç‚¹ï¼ˆå…ˆæŠŠæ‰€æœ‰æ²¡æœ‰æŒ‡å®šçˆ¶èŠ‚ç‚¹çš„èŠ‚ç‚¹æŒ‡å‘è‡ªå·±ï¼Œå³åˆå§‹åŒ–fa[x] = xï¼Œè¿™æ ·findï¼ˆjï¼‰å°±ä¼šåœ¨ièŠ‚ç‚¹å¤„ç»“æŸï¼‰</strong></p>
<p><strong>ä¹Ÿå°±æ˜¯è¯´å½“i = find(j)çš„æ—¶å€™,å¦‚æœæŠŠiçš„çˆ¶èŠ‚ç‚¹è®¾ç½®ä¸ºjï¼Œå°±ä¼šé€ æˆç¯çš„å‡ºç°
æŠ“ä½è¿™ä¸€ç‚¹ï¼Œåœ¨ç¯å³å°†å‡ºç°æ—¶ï¼Œæˆ‘ä»¬å°±å¯ä»¥æŠŠiçš„çˆ¶èŠ‚ç‚¹æ”¹æˆæŒ‡å‘ç»Ÿä¸€çš„æ ¹èŠ‚ç‚¹ï¼Œè¿™æ ·å°±ç”¨ä¸€ä¸ªæ“ä½œå°±æŠŠç¯æ¶ˆé™¤äº†</strong></p>
<p><strong>ä¼˜åŒ–ï¼š
ç”±äºæœ€ç»ˆæˆ‘ä»¬è¦è¾“å‡ºä¸€ä¸ªæœ€å°‘ä¿®æ”¹æ•°é‡çš„æ•°ç»„ï¼Œä½†æ˜¯findå‡½æ•°çš„ä¼˜åŒ–æ˜¯å»ºç«‹åœ¨æŠŠå¤§é‡èŠ‚ç‚¹ç›´æ¥æŒ‚åˆ°æ ¹èŠ‚ç‚¹ä¸‹çš„è¿™ç§æ“ä½œä¸Šçš„ï¼Œæ‰€ä»¥æˆ‘å»ºç«‹äº†å¦ä¸€ä¸ªæ•°ç»„icopyæ¥è®©findå‡½æ•°å¾—ä»¥ä¼˜åŒ–</strong></p>
<pre tabindex="0"><code>#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;cmath&gt;
#include &lt;queue&gt;

using namespace std;

//å¹¶æŸ¥é›†å®ç°
//108ms

/**
*	æ€è·¯:
*	æ‰€æœ‰å¯èƒ½çš„æƒ…å†µå°±ä¸¤ç§,
*	1.æ­£å¸¸çš„æ ‘
*	2.æˆç¯
*	æˆ‘ä»¬è¦åšçš„æ˜¯,æŠŠç¯æ‹†å¼€æˆæ ‘,æŠŠæ‰€æœ‰æ ‘å¹¶åœ¨ä¸€èµ·,è¦åšåˆ°æ“ä½œæ¬¡æ•°æœ€å°‘,é‚£ä¹ˆå½“ç„¶æ˜¯ä¸€ä¸ªç¯åœ¨æŸä¸€ä¸ªåœ°æ–¹æ‹†å¼€,æŒ‡å‘å¦ä¸€ä¸ªæ ¹èŠ‚ç‚¹,ä½†æ˜¯åˆ°åº•æŒ‡å‘å“ªé‡Œæš‚æ—¶è¿˜ä¸çŸ¥é“,æ‰€ä»¥è®©å®ƒå…ˆæŒ‡å‘è‡ªå·±,ç§°ä¸ºå‡æ ¹èŠ‚ç‚¹,è®°å½•ä¸‹è¿™äº›å‡èŠ‚ç‚¹,ä¹‹åå†æ¥å¤„ç†å®ƒçš„å»å‘
*	å¦‚æœæœ‰å¤šä¸ªæ ¹èŠ‚ç‚¹,é€‰å…¶ä¸­ä¸€ä¸ªä½œä¸ºæœ€ç»ˆçš„æ ¹èŠ‚ç‚¹,å…¶ä½™çš„æ ¹èŠ‚ç‚¹å’Œå‡èŠ‚ç‚¹éƒ½å¹¶åœ¨å®ƒçš„ä¸‹é¢[æ“ä½œæ¬¡æ•°=å‡æ ¹èŠ‚ç‚¹çš„æ•°é‡ + æ ¹èŠ‚ç‚¹çš„æ•°é‡ - 1]
*	å¦‚æœæ²¡æœ‰æ ¹èŠ‚ç‚¹,é‚£ä¹ˆæŸä¸€ä¸ªå‡èŠ‚ç‚¹ä½œä¸ºæœ€ç»ˆæ ¹èŠ‚ç‚¹[æ“ä½œæ¬¡æ•° = å‡æ ¹èŠ‚ç‚¹æ•°é‡ + æ ¹èŠ‚ç‚¹æ•°é‡(æ˜¯0)]
*
*/

int n, changes = 0, root;

queue&lt;int&gt; fackRoot;

int fa[200005];//è¿™ä¸ªæ•°ç»„ä½œä¸ºæœ€åçš„è¾“å‡ºç»“æœ
int facopy[200005];//è¿™ä¸ªæ•°ç»„ä½œä¸ºæœ€åçš„è¾“å‡ºç»“æœ

void init() {
	for (int i = 1; i &lt;= n; ++i) {
		facopy[i] = i;
	}
}

int find(int i) {//éé€’å½’å®ç°
	int icopy = i;
	while (i != facopy[i]) {//æ‰¾åˆ°æ ¹å…ƒç´ 
		i = facopy[i];
	}

	while (icopy != facopy[icopy]) {
		icopy = facopy[icopy];//è·å–çˆ¶èŠ‚ç‚¹
		facopy[icopy] = i;//æŒ‚åˆ°æ ¹èŠ‚ç‚¹ä¸‹
	}

	return i;
}

int main(int argc, char const *argv[])
{
	scanf(&quot;%d&quot;, &amp;n);

	init();

	for (int i = 1; i &lt;= n; ++i) {
		scanf(&quot;%d&quot;, fa + i);

		if (fa[i] == i) {
			if (root) {
				changes++;//åšå‡ºæ”¹å˜
				fa[i] = root;
			} else {
				root = i;
			}
			facopy[i] = root;
		} else {
			if (i == find(fa[i])) {//è‹¥å‡ºç°ç¯
				//åŠ å…¥åˆ°fackRoot
				fackRoot.push(i);
				// facopy[i] = i;//æ‹†å¼€ç¯ï¼Œä½œä¸ºå‡çš„æ ¹å…ƒç´ ï¼Œæš‚æ—¶æŒ‡å‘è‡ªå·±
				// ä¸Šé¢è¿™ä¸€æ­¥æ“ä½œä¸ç”¨å†™ï¼Œå› ä¸ºä¹‹å‰å¯¹å¹¶æŸ¥é›†æ‰§è¡Œè¿‡init()æ“ä½œ
			} else {
				facopy[i] = find(fa[i]);//ç›´æ¥æŒ‚åœ¨æ ¹èŠ‚ç‚¹
			}
		}
	}

	// å¤„ç†æ‰€æœ‰fackRoot
	changes += fackRoot.size();
	while (!fackRoot.empty()) {
		if (root) {//è‹¥ä¹‹å‰ç¡®ç«‹äº†æ ¹å…ƒç´ 
			fa[fackRoot.front()] = root;
			fackRoot.pop();
		} else {
			root = fackRoot.front();
		}
	}

	printf(&quot;%d\n&quot;, changes);

	printf(&quot;%d&quot;, fa[1]);

	for (int i = 2; i &lt;= n; ++i) {
		printf(&quot; %d&quot;, fa[i]);
	}

	printf(&quot;\n&quot;);
	return 0;
}

</code></pre>
</main>



<div id="comments">
    <hr>
    <script src="https://utteranc.es/client.js" repo='KB5201314/KB5201314.github.io' issue-term="pathname" label='ğŸ’¬ comments ğŸ’¬'
        theme='github-light' crossorigin="anonymous" async>
        </script>
</div>


  <footer>
  
  <hr/>
  Â© imlk 2017 &ndash; 2021 | <a href="https://blog.imlk.top">imlk's blog</a> | <a href="https://github.com/KB5201314/">Github</a> | <a href="mailto:me@imlk.top">Email</a> | <a href="https://beian.miit.gov.cn/">äº¬ICPå¤‡ - 2020042968å·</a>
  
  </footer>
  </body>
</html>
