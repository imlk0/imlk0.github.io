<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>在WireGuard场景中使用策略路由定义复杂路由规则 | imlk's blog</title><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=/css/fonts.css><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@400;700&display=swap" rel=stylesheet></head><body><header class=header><a class=logo href=/>imlk's Blog</a><nav><ul class=menu><li><a href=/>🏠Home</a></li><li><a href=/about/>👋About</a></li><li><a href=/archives/>📜Archives</a></li><li><a href=/friends/>🔗Friends</a></li><li><a href=/dn42/>🕸️DN42</a></li><li><a href=/index.xml>📢Subscribe</a></li></ul></nav></header><hr><div class=article-meta><h1><span class=title>在WireGuard场景中使用策略路由定义复杂路由规则</span></h1><span><span class=date>📅 2022-11-29</span>
/
<span class=cats>📚
<a href=https://blog.imlk.top/categories/network/>Network</a></span>
/
<span class=tags>🏷️
<a href=https://blog.imlk.top/tags/wireguard/>#wireguard</a>
<a href=https://blog.imlk.top/tags/ip-rule/>#ip-rule</a></span></span><br></div><main><p>今日在配置网络时，遇到一个需求：</p><p>主机上有一个无线网卡<code>wlp44s0</code>连接到路由器，作为默认路由，还有docker和tailscale创建的一些杂七杂八的接口。现在的想法是，要新增一个wireguard隧道<code>wg0</code>连到内网的另一台机器上，让所有的通向外网的TCP流量经过<code>wg0</code>转发，其它不受影响。</p><p>WG的部分已经配好，且使用<code>Table = off</code>属性关闭了wireguard自动生成的路由规则。接下来需要解决我们自定义路由规则的需求。</p><h1 id=iptables-fwmark--snat--ip-rule--ip-route>iptables fwmark + SNAT + ip rule + ip-route</h1><p>由于涉及到对TCP连接的判断，一开始的想法，自然是往iptables上靠。而外网的话，尽管有些蹩脚，也勉强定义为从<code>0.0.0.0/0</code>中去除掉<code>192.168.0.0/16</code>,<code>172.16.0.0/12</code>,<code>10.0.0.0/8</code>,<code>127.0.0.1/32</code>,<code>255.255.255.255/32</code>这些子网这样的范畴，于是有了下面这样的方案：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># Mask packets need to be send via wg0</span>
</span></span><span style=display:flex><span>sudo iptables -t mangle -A wg_wg0 -d 255.255.255.255/32 -j RETURN
</span></span><span style=display:flex><span>sudo iptables -t mangle -A wg_wg0 -d 127.0.0.1/32 -j RETURN
</span></span><span style=display:flex><span>sudo iptables -t mangle -A wg_wg0 -d 192.168.0.0/16 -j RETURN
</span></span><span style=display:flex><span>sudo iptables -t mangle -A wg_wg0 -d 172.16.0.0/12 -j RETURN
</span></span><span style=display:flex><span>sudo iptables -t mangle -A wg_wg0 -d 10.0.0.0/8 -j RETURN
</span></span><span style=display:flex><span>sudo iptables -t mangle -A wg_wg0 -p tcp -j MARK --set-mark <span style=color:#ae81ff>10086</span>
</span></span><span style=display:flex><span>sudo iptables -t mangle -A OUTPUT -j wg_wg0
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Re-write source ip</span>
</span></span><span style=display:flex><span>sudo iptables -A POSTROUTING -t nat -m mark --mark <span style=color:#ae81ff>10086</span> -j SNAT --to-source 10.253.0.2
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Set route for those packets</span>
</span></span><span style=display:flex><span>sudo ip route add default dev wg0 src 10.253.0.2 table <span style=color:#ae81ff>10086</span>
</span></span><span style=display:flex><span>sudo ip rule add fwmark <span style=color:#ae81ff>10086</span> table <span style=color:#ae81ff>10086</span>
</span></span></code></pre></div><blockquote><p>参考了StackExchange上的<a href=https://unix.stackexchange.com/questions/21093/output-traffic-on-different-interfaces-based-on-destination-port>这个</a>讨论</p></blockquote><p>可以理解为以下几个步骤：</p><ul><li>使用iptables在mangle表的OUTPUT链上，将tcp链接附上标记为<code>10086</code></li><li>使用策略路由ip rule方式匹配这些流量，使其用一张新的路由表（table 10086）来路由决策，使其发送到wg0设备</li><li>使用SNAT来改变数据包源地址</li></ul><p>可能是受到了tailscaled的影响，在我的机器上使用这种方案，只能用一会，之后所有的连接都会出问题，又或者是http以及ssh连接正常而https链接不正常，比较诡异。从tcpdump中看，源ip也符合<code>wg0</code>接口的ip。鉴于没有调试出原因，且其SNAT的方式不太优雅，这种方案只能放弃。</p><h1 id=ip-rule--ip-route>ip rule + ip-route</h1><p>最终在浏览ip rule和ip route手册时，发现了一种不需要iptables的，比较优雅的方案。
让我们看看ip rule的参数：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-txt data-lang=txt><span style=display:flex><span>Usage: ip rule { add | del } SELECTOR ACTION
</span></span><span style=display:flex><span>       ip rule { flush | save | restore }
</span></span><span style=display:flex><span>       ip rule [ list [ SELECTOR ]]
</span></span><span style=display:flex><span>SELECTOR := [ not ] [ from PREFIX ] [ to PREFIX ] [ tos TOS ]
</span></span><span style=display:flex><span>            [ fwmark FWMARK[/MASK] ]
</span></span><span style=display:flex><span>            [ iif STRING ] [ oif STRING ] [ pref NUMBER ] [ l3mdev ]
</span></span><span style=display:flex><span>            [ uidrange NUMBER-NUMBER ]
</span></span><span style=display:flex><span>            [ ipproto PROTOCOL ]
</span></span><span style=display:flex><span>            [ sport [ NUMBER | NUMBER-NUMBER ]
</span></span><span style=display:flex><span>            [ dport [ NUMBER | NUMBER-NUMBER ] ]
</span></span><span style=display:flex><span>ACTION := [ table TABLE_ID ]
</span></span><span style=display:flex><span>          [ protocol PROTO ]
</span></span><span style=display:flex><span>          [ nat ADDRESS ]
</span></span><span style=display:flex><span>          [ realms [SRCREALM/]DSTREALM ]
</span></span><span style=display:flex><span>          [ goto NUMBER ]
</span></span><span style=display:flex><span>          SUPPRESSOR
</span></span><span style=display:flex><span>SUPPRESSOR := [ suppress_prefixlength NUMBER ]
</span></span><span style=display:flex><span>              [ suppress_ifgroup DEVGROUP ]
</span></span><span style=display:flex><span>TABLE_ID := [ local | main | default | NUMBER ]
</span></span></code></pre></div><p>首先，ip rule本身的匹配规则中，支持基于<code>ipproto</code>来匹配，这样我可以用<code>ipproto tcp</code>来匹配tcp包。</p><p>接下来要解决匹配目标ip范围的匹配问题，我们有以下这些候选项：</p><ul><li><p><code>oif STRING</code>：这里面有一个<code>oif</code>选项似乎可以根据数据包的出站interface来匹配，乍一眼看，我只需要用<code>oif wlp44s0</code>匹配我的无线网卡，甚至不需要去以蹩脚的方式去匹配目标ip范围。但文档里说<code>oif</code>只有在程序创建socket时绑定到了某个设备上时才能起作用，所以这个选项不管用。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-txt data-lang=txt><span style=display:flex><span>            oif NAME
</span></span><span style=display:flex><span>                  select the outgoing device to match. The outgoing
</span></span><span style=display:flex><span>                  interface is only available for packets originating
</span></span><span style=display:flex><span>                  from local sockets that are bound to a device.
</span></span></code></pre></div></li><li><p><code>to PREFIX</code>：方式也不太优雅，ip rule的<code>not</code>表达式只能在对整条规则起作用。我们无法做到 <code>ipproto tcp not to 192.168.0.0/16 not to 172.16.0.0/12 not to 10.0.0.0/8</code>这样的匹配。</p></li><li><p><code>table main</code>：使用<code>not tcp table main</code>直接跳到<code>main</code>表也是一种选择。但这种方式不适合我的情况，因为tailscale也创建了一些rule，这么做要么会把tailscale的规则忽略，要么会与tailscale产生关联。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-txt data-lang=txt><span style=display:flex><span>0:      from all lookup local
</span></span><span style=display:flex><span>5210:   from all fwmark 0x80000/0xff0000 lookup main
</span></span><span style=display:flex><span>5230:   from all fwmark 0x80000/0xff0000 lookup default
</span></span><span style=display:flex><span>5250:   from all fwmark 0x80000/0xff0000 unreachable
</span></span><span style=display:flex><span>5270:   from all lookup 52
</span></span><span style=display:flex><span>32766:  from all lookup main
</span></span><span style=display:flex><span>32767:  from all lookup default
</span></span></code></pre></div></li></ul><p>最后选择了ip route的<code>throw</code>路由方案，它有点像iptables里的<code>RETURN</code>动作。如果被路由表里的<code>throw</code>类型的路由匹配到，那么将退出该路由表的搜索并假装发生了路由缺失，从而fallback到ip rule里的其他策略，这个策略就非常适合我的场景。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-txt data-lang=txt><span style=display:flex><span>              throw - a special control route used together with policy
</span></span><span style=display:flex><span>              rules. If such a route is selected, lookup in this table
</span></span><span style=display:flex><span>              is terminated pretending that no route was found. Without
</span></span><span style=display:flex><span>              policy routing it is equivalent to the absence of the
</span></span><span style=display:flex><span>              route in the routing table. The packets are dropped and
</span></span><span style=display:flex><span>              the ICMP message net unreachable is generated. The local
</span></span><span style=display:flex><span>              senders get an ENETUNREACH error.
</span></span></code></pre></div><p>所以最终的脚本如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sudo ip route add default dev wg0 src 10.253.0.2 table <span style=color:#ae81ff>10086</span>
</span></span><span style=display:flex><span>sudo ip route add throw 192.168.0.0/16 table <span style=color:#ae81ff>10086</span>
</span></span><span style=display:flex><span>sudo ip route add throw 172.16.0.0/12 table <span style=color:#ae81ff>10086</span>
</span></span><span style=display:flex><span>sudo ip route add throw 10.0.0.0/8 table <span style=color:#ae81ff>10086</span>
</span></span><span style=display:flex><span>sudo ip rule add ipproto tcp table <span style=color:#ae81ff>10086</span>
</span></span></code></pre></div><h1 id=总结>总结</h1><p>之前配网的时候接触<code>ip rule</code>总有这种感觉，<code>ip rule</code>是个好东西，但是它的规则匹配似乎很弱，总会想用iptables set-mask的方式来实现复杂的规则，但是iptables写起来就总是很麻烦。现在看来，<code>ip rule</code>和<code>ip route</code>组合起来还是很强大的，能够实现很多的需求。</p></main><div id=comments><hr><script src=https://utteranc.es/client.js repo=KB5201314/KB5201314.github.io issue-term=pathname label='💬 comments 💬' theme=github-light crossorigin=anonymous async></script></div><footer><hr>© imlk 2017 &ndash; 2021 | <a href=https://blog.imlk.top>imlk's blog</a> | <a href=https://github.com/KB5201314/>Github</a> | <a href=mailto:me@imlk.top>Email</a> | <a href=https://beian.miit.gov.cn/>京ICP备 - 2020042968号</a></footer></body></html>