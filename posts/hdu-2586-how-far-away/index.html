<!DOCTYPE html>
<html lang="zh-cn">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>HDU 2586 How far away ï¼Ÿ | imlk&#39;s blog</title>
  <link rel="stylesheet" href='/css/style.css' />
  <link rel="stylesheet" href='/css/fonts.css' />
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@400;700&display=swap" rel="stylesheet">
</head>

<body>
  <header class="header">
    <a class="logo" href='/'> imlk's Blog </a>
    <nav>
      <ul class="menu">
        
        <li><a href="/">Home</a></li>
        
        <li><a href="/about/">About</a></li>
        
        <li><a href="/archives/">Archives</a></li>
        
        <li><a href="/friends/">Friends</a></li>
        
        <li><a href="/index.xml">Subscribe</a></li>
        
      </ul>
    </nav>
  </header>
  <hr />



<div class="article-meta">
    <h1><span class="title">HDU 2586 How far away ï¼Ÿ</span></h1>
    
    <span>
        <span class="date">2018-03-02</span>
        |
        
        <span class="cats">
            
            
            <a href='https://blog.imlk.top/categories/algorithm/'>Algorithm</a>
            
        </span>
        
        |
        <span class="tags">
            
            <a href='https://blog.imlk.top/tags/hdu/'>#HDU</a>
            
            <a href='https://blog.imlk.top/tags/dp/'>#dp</a>
            
            <a href='https://blog.imlk.top/tags/%E6%A0%91%E4%B8%8A%E6%9C%80%E7%9F%AD%E8%B7%9D%E7%A6%BB/'>#æ ‘ä¸Šæœ€çŸ­è·ç¦»</a>
            
            <a href='https://blog.imlk.top/tags/lca/'>#LCA</a>
            
            <a href='https://blog.imlk.top/tags/%E6%A0%91/'>#æ ‘</a>
            
            <a href='https://blog.imlk.top/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/'>#çº¿æ®µæ ‘</a>
            
        </span>
        
    </span>
    <br>
    
</div>


<main>
    <p>HDU 2586 How far away ï¼Ÿâ€”â€”æ ‘ä¸ŠèŠ‚ç‚¹æœ€çŸ­è·ç¦»ï¼ŒLCAï¼Œ åŒäº²è¡¨ç¤ºæ³•+æš´åŠ›ä»ä¸‹è‡³ä¸Šè¿½æº¯ï¼Œå­©å­é“¾è¡¨ç¤ºæ³•+ï¼ˆTarjan æˆ– æ¬§æ‹‰ç¯æ¸¸RMQ+ï¼ˆST æˆ– SegmentTreeï¼‰ï¼‰</p>
<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2586">http://acm.hdu.edu.cn/showproblem.php?pid=2586</a></p>
<h2 id="å››ç§è§£æ³•">å››ç§è§£æ³•ï¼š</h2>
<p>- åŒäº²è¡¨ç¤ºæ³•+æš´åŠ›ä»ä¸‹è‡³ä¸Šè¿½æº¯
- å­©å­é“¾è¡¨ç¤ºæ³•+Tarjan
- å­©å­é“¾è¡¨ç¤ºæ³•+æ¬§æ‹‰ç¯æ¸¸RMQ+ST
- å­©å­é“¾è¡¨ç¤ºæ³•+æ¬§æ‹‰ç¯æ¸¸RMQ+SegmentTree</p>
<h2 id="å¯¹äºå»ºæ ‘çš„é—®é¢˜è¦è§£å†³çˆ¶èŠ‚ç‚¹å’Œå­èŠ‚ç‚¹çš„é—®é¢˜">å¯¹äºå»ºæ ‘çš„é—®é¢˜ï¼Œè¦è§£å†³çˆ¶èŠ‚ç‚¹å’Œå­èŠ‚ç‚¹çš„é—®é¢˜ï¼š</h2>
<p>- ç¬¬ä¸€ç§è§£æ³•ä¸­ï¼ŒåŒäº²è¡¨ç¤ºæ³•ï¼Œç”¨ä¸€ä¸ªä¸€ç»´æ•°ç»„housesæ¥å‚¨å­˜æ‰€æœ‰èŠ‚ç‚¹ï¼Œhouses[x].faè¡¨ç¤ºè¯¥èŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹ï¼Œå½“ä¸¤ä¸ªå­æ ‘è¢«åˆå¹¶é€ æˆå†²çªæ—¶ï¼Œå°†å…¶ä¸­ä¸€æ£µæ ‘å€’ç½®</p>
<p>å¦‚ï¼š</p>
<blockquote>
<p>1    2
â†‘    â†‘
3    4
â†‘    â†‘
5    6</p>
</blockquote>
<p>æ­¤æ—¶è¦è¿æ¥3å’Œ4ï¼Œå¿…å®šä¼šé€ æˆå†²çªï¼Œå› ä¸ºï¼Œè‹¥å°†3ä½œä¸º4çš„çˆ¶èŠ‚ç‚¹ï¼ˆ3 â†’ 4ï¼‰ï¼Œ4å°±ä¼šæœ‰ä¸¤ä¸ªçˆ¶èŠ‚ç‚¹ï¼Œäºæ˜¯æŠŠ4 â† 6è¿™ä¸€æ”¯å€’ç½®æˆ 4 â†’ 6
äºæ˜¯ï¼š</p>
<blockquote>
<p>1    2
â†‘    â†‘
3  â†’ 4
â†‘    â†“
5    6
ï¼ˆ5æˆä¸ºåˆå¹¶ä»¥åçš„æ ¹å…ƒç´ ï¼‰</p>
</blockquote>
<p>- å‰©ä¸‹ä¸‰ç§è§£æ³•åˆ™åˆ©ç”¨å­©å­é“¾è¡¨ç¤ºæ³•ï¼Œè®°å½•æ‰€æœ‰ä¸ç›®æ ‡èŠ‚ç‚¹ç›¸è¿æ¥çš„èŠ‚ç‚¹ï¼ˆåŒ…æ‹¬ä¸€ä¸ªçˆ¶èŠ‚ç‚¹å’Œä¸€ä¸ªå­èŠ‚ç‚¹ï¼‰ï¼Œç„¶åéšä¾¿é€‰å–ä¸€ä¸ªèŠ‚ç‚¹ä½œä¸ºçˆ¶èŠ‚ç‚¹ï¼Œç”¨dfséå†è¿™äº›è¿æ¥çš„èŠ‚ç‚¹ï¼ŒåŒæ—¶ç”¨visitedæ•°ç»„æ¥è·³è¿‡å…¶ä¸­çš„çˆ¶èŠ‚ç‚¹</p>
<h1 id="è§£æ³•1">è§£æ³•1ï¼š</h1>
<pre tabindex="0"><code>#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;cstring&gt;
#include &lt;string&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;

using namespace std;

//31ms

//åŒäº²è¡¨ç¤ºæ³•

//å½“å»ºæ ‘é‡åˆ°å†²çªæ—¶ï¼Œå°†å†²çªçš„ä¸€æ”¯æ ‘å€’ç½®

struct Node
{
	int disToFa;
	int fa;
};

Node houses[40005];
int visited[40005];

void add(int x, int y, int z) {
	if (!houses[x].fa) {//è‹¥xè¿˜æ²¡æœ‰çˆ¶å…ƒç´ 
		//æŠŠxæŒ‚åœ¨yä¸‹
		houses[x].fa = y;
		houses[x].disToFa = z;

	} else {

		if (!houses[y].fa) { //è‹¥yè¿˜æ²¡æœ‰çˆ¶å…ƒç´ 
			//æŠŠyæŒ‚åœ¨xä¸‹
			houses[y].fa = x;
			houses[y].disToFa = z;
		} else {
			//xå’Œyéƒ½æœ‰çˆ¶å…ƒç´ äº†

			//å°†xçš„çˆ¶å…ƒç´ å‘ä¸Šè¿½æº¯å…¨éƒ¨å˜æˆå­å…ƒç´ ï¼ˆå°†è¿™ä¸€æ”¯ç®­å¤´å…¨éƒ¨å€’ç½®ï¼‰

			//ä¿®æ”¹å‰çš„å‰¯æœ¬
			Node temp_x = houses[x];
			Node temp_x_fa = houses[temp_x.fa];

			//æŠŠxæŒ‚åœ¨yä¸‹
			houses[x].fa = y;
			houses[x].disToFa = z;

			while (temp_x_fa.fa) {

				houses[temp_x.fa].disToFa = temp_x.disToFa;
				houses[temp_x.fa].fa = x;

				x = temp_x.fa;
				temp_x = houses[x];
				temp_x_fa = houses[temp_x.fa];

			}

		}

	}
}

int cal(int x, int y) {
//å…ˆä»xå¼€å§‹ä¸€ç›´è¿½æº¯åˆ°æ ¹èŠ‚ç‚¹ï¼Œæ²¿é€”æ ‡è®°æ‰€æœ‰ç»è¿‡çš„èŠ‚ç‚¹ï¼ˆvisitedæ•°ç»„ä¸¤ä¸ªä½œç”¨ï¼Œä¸€æ˜¯ç”¨æ¥æ ‡è®°æ˜¯å¦è®¿é—®è¿‡ï¼ŒäºŒæ˜¯ç”¨æ¥è®°å½•ä»xèŠ‚ç‚¹å‡ºå‘ä»¥åèµ°è¿‡çš„è·ç¦»ï¼‰
	int sum_x = 0;
	visited[x] = -1;

	sum_x += houses[x].disToFa;
	x = houses[x].fa;

	while (houses[x].fa) {//å½“æœªåˆ°æ ‘é¡¶æ—¶
		visited[x] = sum_x;
		sum_x += houses[x].disToFa;
		x = houses[x].fa;
	}

	//æ­¤æ—¶xæ˜¯æ ‘é¡¶
	if (visited[x] != -1) {
		visited[x] = sum_x;
	}

	//æ¥ä¸‹æ¥ä»yå¼€å§‹å‘ä¸Šè¿½æº¯
	int sum_y = 0;
	while (!visited[y]) {
		sum_y += houses[y].disToFa;
		y = houses[y].fa;
	}

	//æ ¹æ®ä¹‹å‰ç•™ä¸‹çš„-1åˆ¤æ–­åŸå§‹çš„xæ˜¯å¦ä¸ºyçš„çˆ¶å…ƒç´ 
	if (visited[y] == -1) {//è¿™ç§æƒ…å†µè¡¨æ˜yå‘ä¸Šè¿½æº¯çš„è¿‡ç¨‹ä¸­é‡åˆ°äº†x
		return sum_y;//ç›´æ¥è¿”å›yå‘ä¸Šè¿½æº¯åˆ°xçš„è·ç¦»
	} else {//è¿™ç§æƒ…å†µè¡¨æ˜yè¿½æº¯åˆ°äº†xçš„æŸä¸€ä¸ªç¥–å…ˆå…ƒç´ 
		return sum_y + visited[y];//è¿”å›yå‘ä¸Šè¿½æº¯åˆ°xçš„è·ç¦» + ä»xåˆ°è¿™ä¸ªç¥–å…ˆå…ƒç´ çš„è·ç¦»
	}

}

int main(int argc, char const *argv[])
{
	int T, n, m, cp_n, a1, a2, a3;
	scanf(&quot;%d&quot;, &amp;T);
	while (T--) {
		scanf(&quot;%d%d&quot;, &amp;n, &amp;m);

		cp_n = n;

		memset(houses, 0, sizeof(Node) * (n + 1));

		while (--n) {
			scanf(&quot;%d%d%d&quot;, &amp;a1, &amp;a2, &amp;a3);

			add(a1, a2, a3);

		}

		while (m--) {
			scanf(&quot;%d%d&quot;, &amp;a1, &amp;a2);

			memset(visited, 0, sizeof(int) * (cp_n + 1));//æ¯å¤„ç†ä¸€ä¸ªé—®é¢˜å‰åˆ·æ–°ä¸€æ¬¡

			printf(&quot;%d\n&quot;, cal(a1, a2));

		}

	}

	return 0;
}
</code></pre><h1 id="è§£æ³•2">è§£æ³•2ï¼š</h1>
<pre tabindex="0"><code>#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;cstring&gt;
#include &lt;string&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;

using namespace std;

//31ms
//Tarjan

//å­©å­é“¾è¡¨ç¤ºæ³•(é“¾è¡¨)
//è¿™é‡Œçš„å­©å­ä¸ä¸€å®šæ˜¯å­èŠ‚ç‚¹ï¼Œå¯èƒ½è¿˜æœ‰ä¸€ä¸ªçˆ¶èŠ‚ç‚¹ï¼Œä½†æ˜¯å¯ä»¥ç”¨visitedæ•°ç»„æ¥åŒºåˆ«
//éšä¾¿é€‰å–ä¸€ä¸ªhandä½œä¸ºæ ¹èŠ‚ç‚¹ï¼Œå°±å¯ä»¥å»ºæˆä¸€æ£µæ ‘

int hand[40005];//ä¿å­˜ç¬¬xå·æˆ¿å­çš„æ‰€æœ‰å­©å­èŠ‚ç‚¹é“¾è¡¨çš„èµ·å§‹èŠ‚ç‚¹ç¼–å·

struct Node//é“¾è¡¨èŠ‚ç‚¹
{
	int distance;//æƒå€¼
	int to;
	int next;//ä¿å­˜ä¸‹ä¸€ä¸ªNodeçš„ä½ç½®ï¼ˆå¹¶éæŒ‡æˆ¿å­çš„ç¼–å·ï¼Œæ˜¯èŠ‚ç‚¹çš„ç¼–å·ï¼‰ï¼Œå³å­©å­ç»„æˆçš„é“¾è¡¨ä¸­çš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹çš„ä½ç½®
};

Node nodes[40005 &lt;&lt; 1];//éœ€è¦ä¸¤å€ç©ºé—´
int pos;//posä¸ºnodesçš„å½“å‰å¯ç”¨çš„Nodeçš„ä½ç½®ç¼–å·
int disToRoot[40005];//ä»£è¡¨åˆ°æ ¹èŠ‚ç‚¹çš„è·ç¦»
// ç»“æœ = disToRoot[x] + disToRoot[y] - 2 * disToRoot[LCA(x, y)]

//Tarjan
int fa[40005];
int visited[40005];
int qhand[40005];
Node ques[40005 &lt;&lt; 1];
int qpos;

void addToTree(int x, int y, int z) {//è¡¨ç¤ºä¸ºxå·æˆ¿å­æ·»åŠ ä¸€ä¸ªå­èŠ‚ç‚¹ y ,è·ç¦»ä¸ºz
	//ä¸ºposå·èŠ‚ç‚¹å†™å…¥æ•°æ®
	nodes[pos].to = y;
	nodes[pos].distance = z;
	nodes[pos].next = hand[x];
	hand[x] = pos;

	pos++;//å½“å‰å¯ç”¨çš„èŠ‚ç‚¹ç¼–å·+1
}

void addToQue(int x, int y) {
	ques[qpos].to = y;
	ques[qpos].distance = 0;
	ques[qpos].next = qhand[x];
	qhand[x] = qpos;

	qpos++;
}

int tarjanFind(int x) {//å¹¶æŸ¥é›†æŸ¥æ‰¾ï¼ˆéé€’å½’å‹ç¼©è·¯å¾„ï¼‰
	int cp_x = x;
	while (fa[x] != x) {
		x = fa[x];
	}

	while (fa[cp_x] != cp_x) {
		cp_x = fa[cp_x];
		fa[cp_x] = x;
	}

	return x;
}

void tarjan(int which) {

	visited[which] = 1;

	fa[which] = which;

	int childPos = hand[which];

	while (childPos) {

		if (visited[nodes[childPos].to]) {//è·³è¿‡çˆ¶å…ƒç´ 
			childPos = nodes[childPos].next;
			continue;
		}

		disToRoot[nodes[childPos].to] = disToRoot[which] + nodes[childPos].distance;//å†™å…¥åˆ°æ ¹èŠ‚ç‚¹çš„è·ç¦»
		tarjan(nodes[childPos].to);

		fa[nodes[childPos].to] = which;

		childPos = nodes[childPos].next;

	}

//å¤„ç†è¯¢é—®
	int quesPos = qhand[which];

	while (quesPos) {

		if (visited[ques[quesPos].to]) {
			ques[quesPos].distance = disToRoot[which] + disToRoot[ques[quesPos].to] - 2 * disToRoot[tarjanFind(ques[quesPos].to)];
		}

		quesPos = ques[quesPos].next;
	}

}

int main(int argc, char const *argv[])
{
	int T, n, m, a1, a2, a3;
	scanf(&quot;%d&quot;, &amp;T);
	while (T--) {
		scanf(&quot;%d%d&quot;, &amp;n, &amp;m);

		memset(hand, 0, sizeof(int) * (n + 1));
		memset(qhand, 0, sizeof(int) * (n + 1));
		memset(visited, 0, sizeof(int) * (n + 1));

		pos = 1;

		while (--n) {
			scanf(&quot;%d%d%d&quot;, &amp;a1, &amp;a2, &amp;a3);

			addToTree(a1, a2, a3);
			addToTree(a2, a1, a3);

		}

		qpos = 1;

		//ç¦»çº¿ç®—æ³•ï¼ˆå…ˆæ”¶é›†æ‰€æœ‰é—®é¢˜ï¼Œç„¶åç»Ÿä¸€éå†ï¼‰
		while (m--) {

			scanf(&quot;%d%d&quot;, &amp;a1, &amp;a2);

			//å»ºç«‹é“¾è¡¨çš„æ–¹æ³•å’Œä¸Šé¢å»ºæ ‘çš„æ–¹æ³•ç±»ä¼¼
			addToQue(a1, a2);
			addToQue(a2, a1);

		}

		disToRoot[1] = 0;
		tarjan(1);

		for (int i = 1; i &lt; qpos; i += 2) {
			printf(&quot;%d\n&quot;, ques[i].distance ? ques[i].distance : ques[i + 1].distance);
		}

	}

	return 0;
}
</code></pre><h1 id="è§£æ³•3">è§£æ³•3ï¼š</h1>
<pre tabindex="0"><code>#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;cstring&gt;
#include &lt;string&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;

using namespace std;

//46ms
//è½¬åŒ–ä¸ºRMQé—®é¢˜_ST
//åœ¨çº¿ç®—æ³•

//å­©å­é“¾è¡¨ç¤ºæ³•(é“¾è¡¨)
//è¿™é‡Œçš„å­©å­ä¸ä¸€å®šæ˜¯å­èŠ‚ç‚¹ï¼Œå¯èƒ½è¿˜æœ‰ä¸€ä¸ªçˆ¶èŠ‚ç‚¹ï¼Œä½†æ˜¯å¯ä»¥ç”¨visitedæ•°ç»„æ¥åŒºåˆ«
//éšä¾¿é€‰å–ä¸€ä¸ªhandä½œä¸ºæ ¹èŠ‚ç‚¹ï¼Œå°±å¯ä»¥å»ºæˆä¸€æ£µæ ‘

int hand[40005];//ä¿å­˜ç¬¬xå·æˆ¿å­çš„æ‰€æœ‰å­©å­èŠ‚ç‚¹é“¾è¡¨çš„èµ·å§‹èŠ‚ç‚¹ç¼–å·

struct Node//é“¾è¡¨èŠ‚ç‚¹
{
	int distance;//æƒå€¼
	int to;
	int next;//ä¿å­˜ä¸‹ä¸€ä¸ªNodeçš„ä½ç½®ï¼ˆå¹¶éæŒ‡æˆ¿å­çš„ç¼–å·ï¼Œæ˜¯èŠ‚ç‚¹çš„ç¼–å·ï¼‰ï¼Œå³å­©å­ç»„æˆçš„é“¾è¡¨ä¸­çš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹çš„ä½ç½®
};

Node nodes[40005 &lt;&lt; 1];//éœ€è¦ä¸¤å€ç©ºé—´

int pos;//posä¸ºnodesçš„å½“å‰å¯ç”¨çš„Nodeçš„ä½ç½®ç¼–å·
int disToRoot[40005];//ä»£è¡¨åˆ°æ ¹èŠ‚ç‚¹çš„è·ç¦»
// ç»“æœ = disToRoot[x] + disToRoot[y] - 2 * disToRoot[LCA(x, y)]

//RMQ
int rmq_which[40005 &lt;&lt; 1];//RMQæ•°ç»„é•¿åº¦çº¦ä¸ºèŠ‚ç‚¹æ•°çš„ä¸¤å€ï¼ˆå®é™…ä¸Šæ˜¯2n-1ï¼‰ï¼Œå‚¨å­˜æ¬§æ‹‰ç¯æ¸¸ç»è¿‡çš„æ‰€æœ‰èŠ‚ç‚¹å·
int rmq_deep[40005 &lt;&lt; 1];//å‚¨å­˜ç¯æ¸¸ä¸­èŠ‚ç‚¹çš„æ·±åº¦
int rmq_first[40005];//å‚¨å­˜å¾ªç¯ä¸­ x å·èŠ‚ç‚¹ï¼ˆæˆ¿å­ï¼‰ç¬¬ä¸€æ¬¡å‡ºç°çš„ä½ç½®
int rmq_pos;

int visited[40005];//æ’é™¤çˆ¶èŠ‚ç‚¹

//ST
int st[40005 &lt;&lt; 1][18]; //2çš„17æ¬¡æ–¹å¤§äº 40005
// st[x][y] = ä»£è¡¨rmq_deepæ•°ç»„ä¸­ä»xå¼€å§‹æŒç»­é•¿ä¸ºï¼ˆ2çš„yæ¬¡æ–¹ï¼‰é•¿çš„åŒºé—´èŒƒå›´å†…çš„æœ€å°deep çš„ä½ç½®

void addToTree(int x, int y, int z) {//è¡¨ç¤ºä¸ºxå·æˆ¿å­æ·»åŠ ä¸€ä¸ªå­èŠ‚ç‚¹ y ,è·ç¦»ä¸ºz
	//ä¸ºposå·èŠ‚ç‚¹å†™å…¥æ•°æ®
	nodes[pos].to = y;
	nodes[pos].distance = z;
	nodes[pos].next = hand[x];
	hand[x] = pos;

	pos++;//å½“å‰å¯ç”¨çš„èŠ‚ç‚¹ç¼–å·+1
}

/**
* rmqå‡½æ•°ç”¨æ¬§æ‹‰ç¯æ¸¸ç”Ÿæˆäº†rmq_which å’Œ rmq_deep å’Œ rmq_first å’Œ disToRoot å››ä¸ªæ•°ç»„
*/
void rmq(int which, int deep) {
	visited[which] = 1;

	rmq_which[rmq_pos] = which;
	rmq_deep[rmq_pos] = deep;
	rmq_first[which] = rmq_pos;
	rmq_pos++;

	int childPos = hand[which];

	while (childPos) {
		if (visited[nodes[childPos].to]) {
			childPos = nodes[childPos].next;
			continue;
		}

		disToRoot[nodes[childPos].to] = disToRoot[which] + nodes[childPos].distance;

		rmq(nodes[childPos].to, deep + 1);

		rmq_which[rmq_pos] = which;
		rmq_deep[rmq_pos] = deep;
		rmq_pos++;

		childPos = nodes[childPos].next;

	}

}

//åˆå§‹åŒ–stæ•°ç»„
void init_st() {
	for (int i = 0; i &lt; rmq_pos; ++i) {//æ ¹æ®stçš„å®šä¹‰ï¼Œyä¸º0æ—¶ï¼Œst[i][0] = i;
		st[i][0] = i;
	}

	for (int y = 1 ; y &lt; 18; ++y) {
		for (int i = 0; i + (1 &lt;&lt; y) - 1 &lt; rmq_pos; ++i) {
			st[i][y] =	rmq_deep[st[i][y - 1]] &lt; rmq_deep[st[i + (1 &lt;&lt; (y - 1))][y - 1]] ? st[i][y - 1] : st[i + (1 &lt;&lt; (y - 1))][y - 1];
		}
	}
}

// è¿”å›rmq_deepæ•°ç»„åŒºé—´[x, y]ä¹‹é—´çš„æœ€å°å…ƒç´ çš„ä½ç½®
int min_st(int x, int y) {

	if (x &gt; y) {//ä¿è¯è¾“å…¥çš„x &lt;= y;è‹¥ä¸æ»¡è¶³ï¼Œåˆ™åè¿‡æ¥
		return min_st(y, x);
	}

	for (int i = 17; i &gt;= 0; --i) {
		if (x + (1 &lt;&lt; i) - 1 &gt; y) {
			continue;
		}

		if (x + (1 &lt;&lt; i) - 1 == y) {
			return st[x][i];
		} else {
			int temp = min_st(x + (1 &lt;&lt; i), y);
			return rmq_deep[st[x][i]] &lt; rmq_deep[temp] ? st[x][i] : temp;
		}
	}

	return 0;
}

int main(int argc, char const *argv[])
{
	int T, n, m, a1, a2, a3, first = 1;
	scanf(&quot;%d&quot;, &amp;T);
	while (T--) {
		scanf(&quot;%d%d&quot;, &amp;n, &amp;m);

		memset(hand, 0, sizeof(int) * (n + 1));
		memset(visited, 0, sizeof(int) * (n + 1));

		pos = 1;

		while (--n) {
			scanf(&quot;%d%d%d&quot;, &amp;a1, &amp;a2, &amp;a3);

			addToTree(a1, a2, a3);
			addToTree(a2, a1, a3);

		}

		disToRoot[1] = 0;

		//åœ¨çº¿ç®—æ³•ï¼ˆé€ä¸ªå›ç­”é—®é¢˜ï¼‰

		rmq_pos = 0;

		rmq(1, 1);

		init_st();

		if (first) {
			first = 0;
		} else {
			printf(&quot;\n&quot;);
		}

		// for (int i = 0; i &lt; rmq_pos; i++) {
		// 	printf(&quot;%d &quot;, rmq_which[i]);
		// }
		// printf(&quot;\n&quot;);
		// for (int i = 0; i &lt; rmq_pos; i++) {
		// 	printf(&quot;%d &quot;, rmq_deep[i]);
		// }
		// printf(&quot;\n&quot;);
		// for (int i = 1; i &lt;= 6; i++) {
		// 	printf(&quot;%d &quot;, rmq_first[i]);
		// }
		// printf(&quot;\n&quot;);

		// for (int x = 0; x &lt; 18; x++) {
		// 	for (int i = 0; i &lt; rmq_pos; i++) {
		// 		printf(&quot;%d &quot;, st[i][x]);
		// 	}
		// 	printf(&quot;\n&quot;);
		// }

		while (m--) {

			scanf(&quot;%d%d&quot;, &amp;a1, &amp;a2);

			printf(&quot;%d\n&quot;, disToRoot[a1] + disToRoot[a2] - 2 * disToRoot[rmq_which[min_st(rmq_first[a1], rmq_first[a2])]]);

		}

	}

	return 0;
}
</code></pre><h1 id="è§£æ³•4">è§£æ³•4ï¼š</h1>
<pre tabindex="0"><code>#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;cstring&gt;
#include &lt;string&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;

using namespace std;

//31ms
//è½¬åŒ–ä¸ºRMQé—®é¢˜_Segment_Tree

/**
*	æ³¨æ„çº¿æ®µæ ‘éœ€è¦4å€ç©ºé—´
*	æ³¨æ„çº¿æ®µæ ‘éœ€è¦4å€ç©ºé—´
*	æ³¨æ„çº¿æ®µæ ‘éœ€è¦4å€ç©ºé—´
*/

//åœ¨çº¿ç®—æ³•

//å­©å­é“¾è¡¨ç¤ºæ³•(é“¾è¡¨)
//è¿™é‡Œçš„å­©å­ä¸ä¸€å®šæ˜¯å­èŠ‚ç‚¹ï¼Œå¯èƒ½è¿˜æœ‰ä¸€ä¸ªçˆ¶èŠ‚ç‚¹ï¼Œä½†æ˜¯å¯ä»¥ç”¨visitedæ•°ç»„æ¥åŒºåˆ«
//éšä¾¿é€‰å–ä¸€ä¸ªhandä½œä¸ºæ ¹èŠ‚ç‚¹ï¼Œå°±å¯ä»¥å»ºæˆä¸€æ£µæ ‘

int hand[40005];//ä¿å­˜ç¬¬xå·æˆ¿å­çš„æ‰€æœ‰å­©å­èŠ‚ç‚¹é“¾è¡¨çš„èµ·å§‹èŠ‚ç‚¹ç¼–å·

struct Node//é“¾è¡¨èŠ‚ç‚¹
{
	int distance;//æƒå€¼
	int to;
	int next;//ä¿å­˜ä¸‹ä¸€ä¸ªNodeçš„ä½ç½®ï¼ˆå¹¶éæŒ‡æˆ¿å­çš„ç¼–å·ï¼Œæ˜¯èŠ‚ç‚¹çš„ç¼–å·ï¼‰ï¼Œå³å­©å­ç»„æˆçš„é“¾è¡¨ä¸­çš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹çš„ä½ç½®
};

Node nodes[40005 &lt;&lt; 1];//éœ€è¦ä¸¤å€ç©ºé—´

int pos;//posä¸ºnodesçš„å½“å‰å¯ç”¨çš„Nodeçš„ä½ç½®ç¼–å·
int disToRoot[40005];//ä»£è¡¨åˆ°æ ¹èŠ‚ç‚¹çš„è·ç¦»
// ç»“æœ = disToRoot[x] + disToRoot[y] - 2 * disToRoot[LCA(x, y)]

//RMQ
int rmq_which[40005 &lt;&lt; 1];//RMQæ•°ç»„é•¿åº¦çº¦ä¸ºèŠ‚ç‚¹æ•°çš„ä¸¤å€ï¼ˆå®é™…ä¸Šæ˜¯2n-1ï¼‰ï¼Œå‚¨å­˜æ¬§æ‹‰ç¯æ¸¸ç»è¿‡çš„æ‰€æœ‰èŠ‚ç‚¹å·
int rmq_deep[40005 &lt;&lt; 1];//å‚¨å­˜ç¯æ¸¸ä¸­èŠ‚ç‚¹çš„æ·±åº¦
int rmq_first[40005];//å‚¨å­˜å¾ªç¯ä¸­ x å·èŠ‚ç‚¹ï¼ˆæˆ¿å­ï¼‰ç¬¬ä¸€æ¬¡å‡ºç°çš„ä½ç½®
int rmq_pos;

int visited[40005];//æ’é™¤çˆ¶èŠ‚ç‚¹

//Segment_Tree
struct SegNode
{
	int left;
	int right;
	int minPos;//å‚¨å­˜[left, right]åŒºé—´å†…deepæœ€å°å€¼æ‰€å¤„çš„ä½ç½®
};

//çº¿æ®µæ ‘éœ€è¦åŸåŸºç¡€æ•°ç»„é•¿åº¦å››å€çš„ç©ºé—´
SegNode segs[40005 &lt;&lt; 3];//ä»1å¼€å§‹

void addToTree(int x, int y, int z) {//è¡¨ç¤ºä¸ºxå·æˆ¿å­æ·»åŠ ä¸€ä¸ªå­èŠ‚ç‚¹ y ,è·ç¦»ä¸ºz
	//ä¸ºposå·èŠ‚ç‚¹å†™å…¥æ•°æ®
	nodes[pos].to = y;
	nodes[pos].distance = z;
	nodes[pos].next = hand[x];
	hand[x] = pos;

	pos++;//å½“å‰å¯ç”¨çš„èŠ‚ç‚¹ç¼–å·+1
}

/**
* rmqå‡½æ•°ç”¨æ¬§æ‹‰ç¯æ¸¸ç”Ÿæˆäº†rmq_which å’Œ rmq_deep å’Œ rmq_first å’Œ disToRoot å››ä¸ªæ•°ç»„
*/
void rmq(int which, int deep) {
	visited[which] = 1;

	rmq_which[rmq_pos] = which;
	rmq_deep[rmq_pos] = deep;
	rmq_first[which] = rmq_pos;
	rmq_pos++;

	int childPos = hand[which];

	while (childPos) {
		if (visited[nodes[childPos].to]) {
			childPos = nodes[childPos].next;
			continue;
		}

		disToRoot[nodes[childPos].to] = disToRoot[which] + nodes[childPos].distance;

		rmq(nodes[childPos].to, deep + 1);

		rmq_which[rmq_pos] = which;
		rmq_deep[rmq_pos] = deep;
		rmq_pos++;

		childPos = nodes[childPos].next;

	}

}

//åˆå§‹åŒ–segmentæ•°ç»„
void build_seg(int spos, int left, int right) {
	// printf(&quot;spos -&gt; %d\n&quot;, spos);
	segs[spos].left = left;
	segs[spos].right = right;

	if (left == right) {
		segs[spos].minPos = left;
		return;
	}

	build_seg(spos &lt;&lt; 1, left, (left + right) / 2);
	build_seg((spos &lt;&lt; 1) | 1, ((left + right) / 2) + 1, right);

	segs[spos].minPos = rmq_deep[segs[spos &lt;&lt; 1].minPos] &lt; rmq_deep[segs[(spos &lt;&lt; 1) | 1].minPos] ? segs[spos &lt;&lt; 1].minPos : segs[(spos &lt;&lt; 1) | 1].minPos;

}

// è¿”å›rmq_deepæ•°ç»„åŒºé—´[x, y]ä¹‹é—´çš„æœ€å°å…ƒç´ çš„ä½ç½®
int min_seg(int pos, int x, int y) {
	if (x == segs[pos].left &amp;&amp; y == segs[pos].right) {
		return segs[pos].minPos;
	} else if (y &lt;= ((segs[pos].left + segs[pos].right) / 2)) {
		return min_seg(pos &lt;&lt; 1, x, y);
	} else if (x &gt; ((segs[pos].left + segs[pos].right) / 2)) {
		return min_seg((pos &lt;&lt; 1) | 1, x, y);
	} else {
		int temp1, temp2;
		temp1 = min_seg(pos &lt;&lt; 1, x, (segs[pos].left + segs[pos].right) / 2);
		temp2 = min_seg((pos &lt;&lt; 1) | 1, ((segs[pos].left + segs[pos].right) / 2) + 1, y);

		return rmq_deep[temp1] &lt; rmq_deep[temp2] ? temp1 : temp2;
	}
}

int main(int argc, char const *argv[])
{
	int T, n, m, a1, a2, a3, first = 1;
	scanf(&quot;%d&quot;, &amp;T);
	while (T--) {
		scanf(&quot;%d%d&quot;, &amp;n, &amp;m);

		memset(hand, 0, sizeof(int) * (n + 1));
		memset(visited, 0, sizeof(int) * (n + 1));

		pos = 1;

		while (--n) {
			scanf(&quot;%d%d%d&quot;, &amp;a1, &amp;a2, &amp;a3);

			addToTree(a1, a2, a3);
			addToTree(a2, a1, a3);

		}

		disToRoot[1] = 0;

		//åœ¨çº¿ç®—æ³•ï¼ˆé€ä¸ªå›ç­”é—®é¢˜ï¼‰

		rmq_pos = 0;

		rmq(1, 1);

		// printf(&quot;rmq_pos -&gt; %d\n&quot;, rmq_pos);

		build_seg(1, 0, rmq_pos - 1);

		if (first) {//å¥½åƒæ²¡æœ‰ç©ºè¡Œä¹Ÿèƒ½è¿‡
			first = 0;
		} else {
			printf(&quot;\n&quot;);
		}

		// for (int i = 0; i &lt; rmq_pos; i++) {
		// 	printf(&quot;%d &quot;, rmq_which[i]);
		// }
		// printf(&quot;\n&quot;);
		// for (int i = 0; i &lt; rmq_pos; i++) {
		// 	printf(&quot;%d &quot;, rmq_deep[i]);
		// }
		// printf(&quot;\n&quot;);
		// for (int i = 1; i &lt;= 6; i++) {
		// 	printf(&quot;%d &quot;, rmq_first[i]);
		// }
		// printf(&quot;\n&quot;);

		while (m--) {

			scanf(&quot;%d%d&quot;, &amp;a1, &amp;a2);

			if (rmq_first[a1] &lt; rmq_first[a2]) {

				printf(&quot;%d\n&quot;, disToRoot[a1] + disToRoot[a2] - 2 * disToRoot[rmq_which[min_seg(1, rmq_first[a1], rmq_first[a2])]]);
			} else {
				printf(&quot;%d\n&quot;, disToRoot[a1] + disToRoot[a2] - 2 * disToRoot[rmq_which[min_seg(1, rmq_first[a2], rmq_first[a1])]]);
			}

		}

	}

	return 0;
}
</code></pre>
</main>



<div id="comments">
    <hr>
    <script src="https://utteranc.es/client.js" repo='KB5201314/KB5201314.github.io' issue-term="pathname" label='ğŸ’¬ comments ğŸ’¬'
        theme='github-light' crossorigin="anonymous" async>
        </script>
</div>


  <footer>
  
  <hr/>
  Â© imlk 2017 &ndash; 2021 | <a href="https://blog.imlk.top">imlk's blog</a> | <a href="https://github.com/KB5201314/">Github</a> | <a href="mailto:me@imlk.top">Email</a> | <a href="https://beian.miit.gov.cn/">äº¬ICPå¤‡ - 2020042968å·</a>
  
  </footer>
  </body>
</html>
