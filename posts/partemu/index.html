<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>[useuix sec20]PartEmu: Enabling Dynamic Analysis of Real-World TrustZone SoftwareUsing Emulation 论文阅读 | imlk's blog</title><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=/css/fonts.css><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@400;700&display=swap" rel=stylesheet></head><body><header class=header><a class=logo href=/>imlk's Blog</a><nav><ul class=menu><li><a href=/>🏠Home</a></li><li><a href=/about/>👋About</a></li><li><a href=/archives/>📜Archives</a></li><li><a href=/friends/>🔗Friends</a></li><li><a href=/dn42/>🕸️DN42</a></li><li><a href=/index.xml>📢Subscribe</a></li></ul></nav></header><hr><div class=article-meta><h1><span class=title>[useuix sec20]PartEmu: Enabling Dynamic Analysis of Real-World TrustZone SoftwareUsing Emulation 论文阅读</span></h1><span><span class=date>📅 2021-10-15</span>
<span class=date>(更新于2023-08-30)</span>
/
<span class=cats>📚
<a href=https://blog.imlk.top/categories/tee/>TEE</a></span>
/
<span class=tags>🏷️
<a href=https://blog.imlk.top/tags/trustzone/>#TrustZone</a>
<a href=https://blog.imlk.top/tags/security/>#Security</a>
<a href=https://blog.imlk.top/tags/fuzzing/>#Fuzzing</a>
<a href=https://blog.imlk.top/tags/reading/>#Reading</a></span></span><br></div><main class=post-content><h1 id=links>Links</h1><ul><li><a href=https://www.usenix.org/system/files/sec20-harrison.pdf>https://www.usenix.org/system/files/sec20-harrison.pdf</a></li><li>相关源码在2022年3月的三星源码泄漏中出现</li></ul><h1 id=abstract>Abstract</h1><ul><li>目标：<ul><li>为了将一些新的模糊测试技术如feedback-driven fuzz testing带到TrustZone中。</li></ul></li><li>挑战：<ul><li>传统的方法带来的挑战是相应的<strong>模拟通常是不切实际</strong>的（工作量大）</li><li>作者分析了对真实的TZOS进行软硬件模拟所需要的工作。发现这些TZOS<strong>只依赖于有限的硬件和软件组件</strong>，可以只选择这些子集来模拟。</li></ul></li><li>工作：<ul><li>实现了PartEmu，一个可以运行四个现实TZOS以及在它们之上的TAs的仿真器。<ul><li>Qualcomm’s QSEE</li><li>Trustonic’s Kinibi</li><li>Samsung’s TEEGRIS</li><li>Linaro’s OP-TEE</li></ul></li><li>基于QEMU和<a href=https://panda.re/>PANDA</a>实现了一个模块化的框架。整合<a href=https://github.com/google/AFL>AFL</a>的feedback-driven 模糊测试能力。</li></ul></li><li>测试<ul><li>对来自手机厂商和IoT厂商的194个TA进行分析，在48个发现了先前未知的漏洞，其中几个是可以利用的。</li><li>通过测试QSEE TZOS自身，发现了一些通常不会在真实设备上被执行到的，导致程序崩溃的执行路径。</li></ul></li></ul><h1 id=goals>Goals</h1><ul><li>构建一个模拟器来分析<strong>现实世界的TZ软件</strong>，尤其是：<ul><li>在一个模拟器中部署四个现实世界的TZOS和对应的TA的闭源二进制镜像。</li></ul></li><li><strong>兼容性</strong>：能够运行和现实设备中一样的TZOS和TA</li><li><strong>重现性</strong>：具有保真性，以便发现的问题能够在真实设备重现</li><li><strong>可行性</strong>：需要设计可行的硬件和软件仿真工作</li></ul><h1 id=分析tzos的依赖>分析TZOS的依赖</h1><p><img src=/images/%5Buseuix%20sec20%5DPartEmu%20Enabling%20Dynamic%20Analysis%20of%20ed0a853757124921a3eb26676fa17fe5/Untitled.png alt=Untitled></p><h3 id=启动时依赖bootloadersecure-monitor>启动时依赖（bootloader、secure monitor）</h3><ul><li>(B1)bootloader<strong>向TZOS提供boot information</strong> structure。<ul><li>包含硬件信息，如RAM的物理地址范围</li></ul></li><li>(B1)bootloader<strong>加载TZOS</strong>的二进制文件并启动TZOS</li><li>(B2)TZOS启动完成后<strong>将控制权交回给secure monitor</strong>，以及再次调用TZOS所需的信息</li></ul><h3 id=运行时依赖tee-driversecure-monitorta>运行时依赖（TEE driver、secure monitor、TA）</h3><ul><li>(R1)CA请求TEE driver<strong>发出<code>SMC</code>调用</strong></li><li>(R2)secure monitor决定是否要<strong>转发给TZOS</strong></li><li>(R3)TZOS将请求<strong>转发给TA</strong></li></ul><h3 id=硬件依赖>硬件依赖</h3><ul><li><strong>依赖于硬件来实现访问控制</strong>，例如依赖TZASC、TZPC(Trustzone Protection Controller用于区分外设是secure还是non-secure)来设置内存和中断</li><li>还可能<strong>依赖密码学协处理器</strong>(cryptography co-processor)，后者能够获取设备唯一硬件密钥（device-unique hardware key）</li><li>TZOS或者secure monitor还<strong>与大多数硬件组件交互</strong>，取决于具体实现</li></ul><h1 id=如何选择需要模拟的组件>如何选择需要模拟的组件</h1><h3 id=软件组件>软件组件</h3><p>只<strong>模拟相关的部分</strong>，例如TZOS对bootloader只依赖于加载和设置参数</p><h3 id=硬件组件>硬件组件</h3><p>因为secure boot和code signing，无法在真实的设备上运行软件代理。因此需要<strong>通过模拟</strong>的方式实现那些需要的硬件。</p><h3 id=选择模拟-or-重用的指标>选择模拟 or 重用的指标</h3><p><img src=/images/%5Buseuix%20sec20%5DPartEmu%20Enabling%20Dynamic%20Analysis%20of%20ed0a853757124921a3eb26676fa17fe5/Untitled%201.png alt=Untitled></p><h1 id=软件仿真>软件仿真</h1><h3 id=bootloader>Bootloader</h3><ul><li>和TZOS的耦合：传递硬件信息、加载TZOS、移交控制权</li><li>和其他组件的耦合：例如与storage controller(e.g., eMMC, UFS)紧耦合</li></ul><h3 id=secure-monitor>Secure Monitor</h3><ul><li>和TZOS耦合：TZOS依赖于世界切换，依赖于SecureMonitor提供硬件的API（通常是Secure Monitor与硬件直接交互）<ul><li>TEEGRIS：secure monitor被硬件密钥加密，需要通过逆向TZOS来找出依赖的SMC API</li><li>Kinibi：只有少数SMC API，并且设计良好。</li><li>QSEE：相当紧耦合</li><li>OP-TEE：secure monitor和TZOS是一起编译的，无法解耦</li></ul></li><li>和其他组件的耦合：<ul><li>Kinibi：一些硬件组件如厂商特定的密码学协处理器、PRNG，难以模拟</li><li>QSEE：耦合低，因为QSEE通常直接访问硬件而不通过Secure Monitor</li></ul></li></ul><h3 id=tee-driver和tee-userspace>TEE Driver和TEE Userspace</h3><ul><li>TEE Driver和TZOS耦合<ul><li>TEE Driver和TZOS之间的交互：<ul><li>启动TA</li><li>设置CA和TA之间的共享内存</li><li>将CA的命令发送到TA</li><li>响应TZOS的请求（例如访问normal world文件系统）</li></ul></li><li>同步/异步通信<ul><li>同步：如QSEE、OP-TEE：将请求作为SMC的参数然后阻塞知道TZOS响应</li><li>异步：如Kinibi、TEEGRIS：将请求放在共享的请求/响应队列中。周期性地调用SMC以将控制权交给TZOS。</li></ul></li></ul></li><li>TEE Driver和其他组件的耦合<ul><li>TEE Driver可能依赖TEE userspace来处理功能，如从文件系统中读取文件、访问RPMB<ul><li>QSEE、OP-TEE不需要，TEEGRIS、Kinibi需要</li></ul></li></ul></li><li>TEE Userspace<ul><li>Kinibi、TEEGRIS、QSEE的镜像是从Android设备上提取的，其中用户空间的二进制文件是为Android编译的。相比于引入对Android的模拟，直接模拟这部分要更容易得多</li></ul></li></ul><h1 id=硬件仿真>硬件仿真</h1><p><strong>TZOS的硬件访问通过MMIO实现</strong>，即硬件寄存器的值通过访问内存地址获得。</p><h3 id=具有特定的访问模式>具有特定的访问模式</h3><p><img src=/images/%5Buseuix%20sec20%5DPartEmu%20Enabling%20Dynamic%20Analysis%20of%20ed0a853757124921a3eb26676fa17fe5/Untitled%202.png alt=Untitled></p><ul><li>读常量值</li><li>写后读</li><li>读值会逐渐递增的寄存器</li><li>读随机值寄存器，例如伪随机数生成器</li><li>轮询(Poll)：寄存器的值在一个特定事件完成后被设置</li><li>Shadow, Commit, and Target：需要写多个寄存器的情况。先写多个影子寄存器，然后原子性地提交，防止在小时间窗口内出现错误</li></ul><h3 id=定位mmio地址范围>定位MMIO地址范围</h3><ul><li>Kinibi：允许从启动信息（boot information structure）中指定MMIO范围</li><li>QSEE/TEEGRIS/OP-TEE：均假定特定的内存区域为MMIO<ul><li>QSEE将二进制文件页表信息中，具有non-cacheable属性的范围当作MMIO范围</li><li>TEEGRIS/OP-TEE：可以从Linux内核的设备树中取得MMIO的范围</li></ul></li></ul><h3 id=其余硬件的模拟>其余硬件的模拟</h3><p>只需要额外对三个设备进行仿真：</p><ul><li>ARM标准的<strong>GIC(global interrupt controller)</strong>，QEMU提供</li><li>有限的<strong>加密硬件</strong>仿真，例如QSEE依赖的加密协处理器。<ul><li>只需要为QSEE实现一个SHA-2算法，其余TZOS都使用软件实现的加密</li></ul></li><li>TZEEGRIS依赖一个<strong>标准的RTC</strong>（real-time clock），QEMU提供</li></ul><h1 id=partemu的实现>PartEmu的实现</h1><ul><li>PartEmu为PANDA增加了一组运行管理API。并在此之上实现了两个模块<ul><li>fuzz testing with AFL：使用AFL进行测试</li><li>LLVM run module：输出目标的LLVM IR表示，可以被送入到符号分析引擎如KLEE，S2E</li></ul></li></ul><h3 id=afl模块>AFL模块</h3><p>基于<a href=https://github.com/nccgroup/TriforceAFL>TriforceAFL</a>实现，后者能够让目标程序在QEMU中运行并执行AFL测试，就像运行被测试的正常进程那样。</p><p>因为PartEmu需要单独控制启动QEMU，因此作者额外实现了一个代理与AFL进行交互。</p><p><strong>使用AFL时的挑战</strong>：</p><ul><li>需要为AFL<strong>圈定被测试的目标</strong>（的地址空间范围），例如特定的TA。<ul><li>Kinibi、TEEGRIS：使用8位的<a href=https://community.arm.com/support-forums/f/architectures-and-processors-forum/5229/address-space-identifier---asid>ASID(Address Space Identifier)</a>来区分不同的TA所在的地址空间</li><li>QSEE、OP-TEE：不区分ASID，但是可以用程序计数器的值所在的地址空间范围来区分。<ul><li>QSEE：TA的地址空间是在加载TA时，由normal world申请的</li><li>OP-TEE：在二进制中硬编码内存区域</li></ul></li></ul></li><li><strong>稳定性</strong>：相同的输入应该导致相同的输出，但是面临中断、随机数带来的影响<ul><li>在运行过程中，禁止到安全世界的中断</li><li>在开始测试前fork PartEmu进程，以消除先前的测试导致的状态改变。</li><li>伪随机数：用常量值来替代</li><li>QEMU对翻译块的串联（<a href=https://qemu.readthedocs.io/en/latest/devel/tcg.html#direct-block-chaining>translation-block chaining</a>）优化会导致AFL错失被串联的块。关闭这种优化带来效率显著降低。作者通过在每个块的末尾增加一个QEMU IR callback来捕获这些错失的块。</li></ul></li></ul><h3 id=ta-authentication>TA Authentication</h3><p>TA在加载时需要进行两种检查</p><ul><li>签名检查<ul><li>QSEE：将TA中的根证书的hash值和内存中存储的hash值比较，这块内存区域是被映射到<a href=https://electronics.stackexchange.com/a/455773>OTP fuses</a>上的。难以也没有必要从真实设备上取得这个hash值，因为它们在不同厂商之间并不通用。作者的做法是直接从TA的根证书中计算hash值</li><li>Kinibi、OP-TEE、TEEGRIS的TA认证使用在TZOS中硬编码的公钥来验证签名</li></ul></li><li>版本检查（防止回滚）<ul><li>能够接受的最小TA版本信息通常被存储在RPMB中，作者使用两步来绕过：<ul><li>修改TA二进制文件中的版本号为0，使用自己的签名来重新签名。</li><li>模拟RPMB接口，在查询最小可接受TA版本时提供0值</li></ul></li></ul></li></ul><p>作者通过绕过这两种检查，可以获得的能力：</p><ul><li>编写和部署自定义TA</li><li>允许在使用相同类型的TZOS的厂商的不同固件之上，测试TA</li><li>允许为TA文件插桩，进行性能优化等</li></ul><h1 id=evaluation>Evaluation</h1><p>分为3部分</p><ul><li>量化需要进行的软硬件模拟，以显示其可行性</li><li>使用AFL来查找真实世界中的漏洞案例，以证明仿真的有效性</li><li>在真实设备上评估仿真结果的可复现性</li></ul><h3 id=仿真的程度>仿真的程度</h3><p>目标</p><ul><li>QSEE v4.0 (Android)</li><li>Kinibi v400A (Android)</li><li>TEEGRIS v3.1 (Android)</li><li>32-bit OP-TEE (IoT)</li></ul><p>实现：52个数据字段、17个SMC调用、235个MMIO寄存器、额外三个外设</p><p>TZOS更新：对于不同版本的TZOS之间，只需少数的修改就能够支持</p><h3 id=fuzz-testing-tas>Fuzz Testing TAs</h3><p>数据：收集了<strong>12个厂商</strong>的<strong>16个TZOS镜像文件</strong>，都属于上面四种TZOS。一共获得<strong>273个TA</strong>，<strong>去重后一共194个TA</strong>。</p><p>测试方法：</p><ul><li>编写了运行在正常世界的Linux Kernel驱动程序（对于TEEGRIS的测试），或者是运行在正常世界的用户空间的程序(as a normal-world stub)，通过PartEmu的API与AFL模块通信，接收AFL提供的fuzzing输入。</li><li>程序请求TZOS加载TA并设置共享内存</li><li>为TA设置fuzz输入，通过SMC将控制交给TA</li><li>通过返回值来检测crash，所有这些TZOS都会通过特定的返回值表明TA已经崩溃</li></ul><p>测试结果：</p><ul><li>194个TA中崩溃48次</li></ul><p><img src=/images/%5Buseuix%20sec20%5DPartEmu%20Enabling%20Dynamic%20Analysis%20of%20ed0a853757124921a3eb26676fa17fe5/Untitled%203.png alt=Untitled></p><ul><li><p>通过手动逆向分析每一次崩溃的原因，将崩溃相关的参数分类为：机密性(confidentiality)、完整性(integrity)、可用性(availability)：</p><p><img src=/images/%5Buseuix%20sec20%5DPartEmu%20Enabling%20Dynamic%20Analysis%20of%20ed0a853757124921a3eb26676fa17fe5/Untitled%204.png alt=Untitled></p><ul><li>可用性方面：共享单个TA实例的问题<ul><li>QSEE：所有CA共享一个TA实例</li><li>Kinibi、OP-TEE、TEEGRIS：由一个属性flags控制是否是单实例TA</li></ul></li><li>机密性和完整性：<ul><li>根据TA的不同功能危害不同，作者声称能够演示三种情况：<ul><li>读写RPMB</li><li>泄漏DRM密钥</li><li>破解一次性密码TA</li></ul></li></ul></li></ul></li><li><p>作者发现这些错误存在一定的模式</p><ul><li>来自normal world的调用顺序的假设</li><li>解引用来自normal world的未经验证的指针</li><li>未验证对来自normal world的缓冲区数据是否是合法的类型</li></ul></li></ul><h2 id=能否重现崩溃>能否重现崩溃？</h2><p>48个崩溃中，有24个拥有相应的设备，并且这24个都能够在真实设备上重现。</p><ul><li>这其中包含了2个需要访问未被仿真的硬件的TA</li><li>在剩余的crash中，还有3个TA也访问了专用硬件。</li><li>即使保守地认为这三个TA是假阳性，PartEmu也<strong>拥有45/48（93%）的真阳性率</strong></li></ul><h2 id=case-fuzz-testing-tzos>Case: Fuzz Testing TZOS</h2><p>测试方法：在内核驱动中利用AFL生成的输入，对QSEE4.0的SMC API进行模糊测试</p><p>结论：</p><ul><li>AFL共识别到124种SMC，并在其中3个里触发crash。</li><li>这些crash只影响TZOS的可用性，对安全的影响有限。</li><li>导致崩溃的代码路径通常不会在真实设备中触发，除非正常世界（如内核驱动部分）被攻击者破坏。</li></ul><h2 id=展望>展望</h2><h3 id=dealing-with-stateful-tas>Dealing with Stateful TAs</h3><ul><li>基本块的覆盖率平均只有17.7%。</li><li>多数TA内部有有限状态机，需要一连串的输入来驱动它们进入有趣的状态</li><li>作者的测试中每次只会向一个新的PartEmu实例发送一个消息</li></ul><h3 id=hardware-roots-of-trust>Hardware Roots of Trust</h3><ul><li>PartEmu无法模拟硬件信任根，例如出厂时烧写的密钥，一些远程认证相关的任务无法被测试覆盖。</li></ul><h3 id=performance>Performance</h3><ul><li>PartEmu运行在x86机器上，无法利用ARMv8的硬件虚拟化</li><li>对于QSEE\OP-TEE\TEEGRIS，AFL每秒运行10-25次执行。对于Kinibi由于作者进行优化，能够每秒运行125次执行</li><li>作者计划探索直接在ARMv8硬件上运行PartEmu（没找到）</li></ul></main><div id=comments><hr><script src=https://utteranc.es/client.js repo=KB5201314/KB5201314.github.io issue-term=pathname label='💬 comments 💬' theme=github-light crossorigin=anonymous async></script></div><footer class=footer><hr>© imlk 2017 &ndash; 2023 | <a href=https://blog.imlk.top>imlk's blog</a> | <a href=https://github.com/KB5201314/>Github</a> | <a href=mailto:me@imlk.top>Email</a> | <a href=https://beian.miit.gov.cn/>京ICP备2020042968号-1</a></footer></body></html>