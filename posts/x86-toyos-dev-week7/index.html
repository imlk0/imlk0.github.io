<!DOCTYPE html>
<html lang="zh-cn">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>自制x86玩具操作系统 week7 | imlk&#39;s blog</title>
  <link rel="stylesheet" href='/css/style.css' />
  <link rel="stylesheet" href='/css/fonts.css' />
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@400;700&display=swap" rel="stylesheet">
</head>

<body>
  <header class="header">
    <a class="logo" href='/'> imlk's Blog </a>
    <nav>
      <ul class="menu">
        
        <li><a href="/">Home</a></li>
        
        <li><a href="/about/">About</a></li>
        
        <li><a href="/archives/">Archives</a></li>
        
        <li><a href="/friends/">Friends</a></li>
        
        <li><a href="/index.xml">Subscribe</a></li>
        
      </ul>
    </nav>
  </header>
  <hr />



<div class="article-meta">
    <h1><span class="title">自制x86玩具操作系统 week7</span></h1>
    
    <span>
        <span class="date">2019-05-01</span>
        |
        
        <span class="cats">
            
            
            <a href='https://blog.imlk.top/categories/osdev/'>OSDev</a>
            
        </span>
        
        |
        <span class="tags">
            
            <a href='https://blog.imlk.top/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/'>#操作系统</a>
            
            <a href='https://blog.imlk.top/tags/diy/'>#DIY</a>
            
        </span>
        
    </span>
    <br>
    
</div>


<main>
    <h2 id="day-0x12">DAY 0x12</h2>
<h4 id="让新进程执行对象的成员函数">让新进程执行对象的成员函数</h4>
<p>今天回看之前的内容，发现命令行窗口那一块比较乱，于是乎建了一个<code>Console</code>类，把和控制台有关的比如图层、<code>Fifo</code>队列等打包起来，然后把进程的执行函数<code>console_task</code>改成无参的成员函数，但是要知道它其实是隐式传入了一个<code>this</code>指针，所以在设置<code>eip</code>的时候可不是仅仅传入成员函数指针那么容易。</p>
<p>c++的编译器在调用函数时传入this指针时的方法称为<code>__thiscall</code>调用约定，有两种实现，一种是通过<code>ecx</code>寄存器传参，另一种是压栈为第一个参数传参。
要确定当前编译器使用的是哪种<code>__thiscall</code>调用约定，直接拿个例子编译一下看看就好了。</p>
<p>先拿了一个直接用对象去调用成员函数的例子来观察，
<img src="/images/blog/os/9.png" alt="9.png">
可以看到，普通成员函数其实只是一个一般的函数，但是在调用前将这个对象的指针赋值给了<code>ecx</code>寄存器，这个<code>ecx</code>就是this指针啦。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">	task_cons<span style="color:#f92672">-&gt;</span>tss.esp <span style="color:#f92672">=</span> memman_alloc_4k(memman, <span style="color:#ae81ff">64</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">1024</span>) <span style="color:#f92672">+</span> <span style="color:#ae81ff">64</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">1024</span> <span style="color:#f92672">-</span> <span style="color:#ae81ff">4</span>; <span style="color:#75715e">// 没有用栈传递的参数，这里只要预留压栈ebx所需的空间即可
</span><span style="color:#75715e"></span>	task_cons<span style="color:#f92672">-&gt;</span>tss.ecx <span style="color:#f92672">=</span> (<span style="color:#66d9ef">int</span>)<span style="color:#66d9ef">this</span>; <span style="color:#75715e">// this指针通过ecx传递
</span><span style="color:#75715e"></span>	task_cons<span style="color:#f92672">-&gt;</span>tss.eip <span style="color:#f92672">=</span> (<span style="color:#66d9ef">int</span>) (<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>console_task; <span style="color:#75715e">// 指定成员函数
</span><span style="color:#75715e"></span>	...
	<span style="color:#75715e">// 可以通过this指针访问成员变量，这里不用费心思从栈上传一堆参数了
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// *((int *) (task_cons-&gt;tss.esp + 4)) = (int)canvas_cons;
</span><span style="color:#75715e"></span>
</code></pre></div><h4 id="支持美式键盘">支持美式键盘</h4>
<p>之前做的时候没有注意到作者的键盘映射居然不是美式的，怪不得有些按键效果不太对
从网上找到一份类似的键盘映射表换一下就好了</p>
<p><a href="https://github.com/gdevic/linice/blob/829862cb11e4f062d561c854536fa338985672bb/linsym/Keymaps.c">https://github.com/gdevic/linice/blob/829862cb11e4f062d561c854536fa338985672bb/linsym/Keymaps.c</a></p>
<h2 id="day-0x13">DAY 0x13</h2>
<h4 id="改用c编译器后患无穷">改用c++编译器后患无穷</h4>
<p>之前提到我现在的代码用的是c++来编写，编译器用的mingw64里的c++，在做<code>type</code>命令时，遇到了一个玄学bug。</p>
<p>其中一段代码如下</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">		<span style="color:#66d9ef">int</span> x;
		<span style="color:#66d9ef">for</span> (x <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; x <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">224</span>; x<span style="color:#f92672">++</span>) {<span style="color:#75715e">// 遍历所有文件
</span><span style="color:#75715e"></span>			<span style="color:#66d9ef">if</span> (sys<span style="color:#f92672">::</span>finfo[x].name[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">==</span> <span style="color:#ae81ff">0x00</span>) {<span style="color:#75715e">// 后面没有任何文件了
</span><span style="color:#75715e"></span>				<span style="color:#66d9ef">break</span>;
			}
			<span style="color:#75715e">// 判断文件名称是否符合
</span><span style="color:#75715e"></span>			<span style="color:#66d9ef">if</span> ((sys<span style="color:#f92672">::</span>finfo[x].type <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">0x18</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
				<span style="color:#66d9ef">bool</span> flag <span style="color:#f92672">=</span> true;
				<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> y <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; y <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">11</span>; <span style="color:#f92672">++</span>y) {<span style="color:#75715e">// 遍历文件名中的char
</span><span style="color:#75715e"></span>					<span style="color:#66d9ef">if</span> (sys<span style="color:#f92672">::</span>finfo[x].name[y] <span style="color:#f92672">!=</span> file_name[y]) {<span style="color:#75715e">// 和参数中的文件名比较
</span><span style="color:#75715e"></span>						LOGD(<span style="color:#e6db74">&#34;%d nq %d at %d&#34;</span>, (<span style="color:#66d9ef">int</span>)sys<span style="color:#f92672">::</span>finfo[x].name[y], (<span style="color:#66d9ef">int</span>)file_name[y], y);
						LOGD(<span style="color:#e6db74">&#34;f0:%se&#34;</span>,sys<span style="color:#f92672">::</span>finfo[x].name);
						LOGD(<span style="color:#e6db74">&#34;f1:%se&#34;</span>,file_name);

						flag <span style="color:#f92672">=</span> false;
						<span style="color:#66d9ef">break</span>;
					}
				}
				<span style="color:#66d9ef">if</span> (flag) {
					<span style="color:#66d9ef">break</span>;
				}
			}
		}
</code></pre></div><p>看一下运行结果
<img src="/images/blog/os/10.png" alt="10.png">
注意到log里倒数第三行，<code>32 nq 0 at 13</code>，
首先说明一下，这里比较的是文件名的11个字符（文件名8byte+扩展名3byte，处理时跳过了小数点）。
它看起来比较时匹配到了MakeFile这个文件，但是在文件名索引为13(即y=13)的地方发生不匹配。</p>
<p>what happened？ y怎么可能等于13？？？？？</p>
<p>上面for循环判断不是写着<code>y &lt; 11</code>吗，程序疯了吧。
看一下<code>FILEINFO</code>结构体的定义</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">FILEINFO</span> {
	<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span> name[<span style="color:#ae81ff">8</span>], ext[<span style="color:#ae81ff">3</span>], type;
	<span style="color:#66d9ef">char</span> reserve[<span style="color:#ae81ff">10</span>];
	<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">short</span> time, date, clustno;<span style="color:#75715e">// clustno 表示起始扇区
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> size;
};
</code></pre></div><p>看起来作者是用了一个结构体的特性，<code>name</code>（文件名）和<code>ext</code>（后缀）的内存是连续放置的，所以作者打算一次性比较11个字符来匹配文件名和后缀。
但是为什么这里y能跑到13呢？难道是内存不够了篡改了y的值？但是输出那里没法解释啊，输出的y是13，总不会是输出函数有问题吧。</p>
<p>为了探寻真相，来看看汇编
<img src="/images/blog/os/11.png" alt="11.png">
由于有字符串，这段代码并不难找到，上方是循环体，<code>loc_494</code>是for循环的判断，看起来<code>eax</code>就是那个<code>y</code>变量，奇怪的是，在<code>loc_494</code>那里让<code>y</code>加一然后就<code>jmp</code>走继续执行循环体了，没看到和循环边界<code>11</code>比较的<code>cmp</code>部分，吃惊。
开始猜测是傻逼编译器又给我优化了，把for循环里<code>y</code>的上界改成<code>8</code>编译试试看。
<img src="/images/blog/os/12.png" alt="12.png">
只见原来的<code>jmp</code>变成了<code>jnz</code>，跳转指令之前出现了一条<code>cmp</code>指令，傻逼编译器石锤了！</p>
<p>解决办法，把<code>sys::finfo[x].name</code>赋值给一个临时变量，这样傻逼编译器就看不到它的长度，也就不会优化了，骗过了编译器</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> aim_name <span style="color:#f92672">=</span> (<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span>)sys<span style="color:#f92672">::</span>finfo[x].name;
</code></pre></div><p>不过这个傻逼编译器为什么要把我这个给优化掉呢？？</p>
<h4 id="hlthrb">hlt.hrb</h4>
<p><code>hlt.hrb</code>里面本质上是编译好的机器指令，
那么<code>bootpack.hrb</code>应该也是机器指令，那么<code>OBJ2BIM</code>应该就是链接器，<code>haribote.sys</code>就是<code>asmhead.bin</code>和<code>bootpack.hrb</code>这两个机器指令文件组合起来的，所以也是编译好的机器指令。</p>
<h2 id="day-0x14">DAY 0x14</h2>
<p>最后作者传入字符串地址最后什么都没有输出，先看了一下后一天的内容，发现作者又是通过在别处内存处存储临时的值来实现的，感觉这样很别扭，于是想能否获取到要打印的字符串的地址然后把地址传过去，作者说遇到的问题是分段的问题，尝试了一番，发现可以把<code>CS</code>段寄存器的值先存到别的寄存器，然后在<code>hrb_api</code>里面恢复出来传到<code>cons_putstr</code>里面，再在<code>naskfunc</code>里面写一个依据段寄存器和偏移地址取数据的函数，让<code>cons_putstr</code>去调用取字符。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">cons_putstr</span>(Console <span style="color:#f92672">*</span>console, <span style="color:#66d9ef">int</span> ds, <span style="color:#66d9ef">int</span> ecx) {
	<span style="color:#66d9ef">char</span> ch;
	<span style="color:#66d9ef">while</span> (ch <span style="color:#f92672">=</span> get_data(ds, ecx)) {
		console<span style="color:#f92672">-&gt;</span>putfont8(ch);
		ecx<span style="color:#f92672">++</span>;
	}
}
</code></pre></div><pre tabindex="0"><code class="language-assembly" data-lang="assembly">_get_data:		; int get_data(int ds, int ecx);
		MOV		ECX,[ESP+8]
		MOV		EAX,[ESP+4]
		MOV		EDX,DS
		MOV		DS,EAX
		MOV		EAX,0
		MOV		AL,[DS:ECX]
		MOV		DS,EDX
		RET
</code></pre>
</main>



<div id="comments">
    <hr>
    <script src="https://utteranc.es/client.js" repo='KB5201314/KB5201314.github.io' issue-term="pathname" label='💬 comments 💬'
        theme='github-light' crossorigin="anonymous" async>
        </script>
</div>


  <footer>
  
  <hr/>
  © imlk 2017 &ndash; 2021 | <a href="https://blog.imlk.top">imlk's blog</a> | <a href="https://github.com/KB5201314/">Github</a> | <a href="mailto:me@imlk.top">Email</a> | <a href="https://beian.miit.gov.cn/">京ICP备 - 2020042968号</a>
  
  </footer>
  </body>
</html>
