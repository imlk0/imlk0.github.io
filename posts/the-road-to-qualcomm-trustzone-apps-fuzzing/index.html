<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>[RECON Montreal 2019] The Road to Qualcomm TrustZone Apps Fuzzing 文章阅读 | imlk's blog</title><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=/css/fonts.css><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@400;700&display=swap" rel=stylesheet></head><body><header class=header><a class=logo href=/>imlk's Blog</a><nav><ul class=menu><li><a href=/>🏠Home</a></li><li><a href=/about/>👋About</a></li><li><a href=/archives/>📜Archives</a></li><li><a href=/friends/>🔗Friends</a></li><li><a href=/dn42/>🕸️DN42</a></li><li><a href=/index.xml>📢Subscribe</a></li></ul></nav></header><hr><div class=article-meta><h1><span class=title>[RECON Montreal 2019] The Road to Qualcomm TrustZone Apps Fuzzing 文章阅读</span></h1><span><span class=date>📅 2021-10-29</span>
<span class=date>(更新于2023-08-30)</span>
/
<span class=cats>📚
<a href=https://blog.imlk.top/categories/tee/>TEE</a></span>
/
<span class=tags>🏷️
<a href=https://blog.imlk.top/tags/trustzone/>#TrustZone</a>
<a href=https://blog.imlk.top/tags/security/>#Security</a>
<a href=https://blog.imlk.top/tags/fuzzing/>#Fuzzing</a>
<a href=https://blog.imlk.top/tags/reading/>#Reading</a></span></span><br></div><main class=post-content><ul><li><p><a href=https://research.checkpoint.com/2019/the-road-to-qualcomm-trustzone-apps-fuzzing/>https://research.checkpoint.com/2019/the-road-to-qualcomm-trustzone-apps-fuzzing/</a></p></li><li><p><a href=https://cfp.recon.cx/media/tz_apps_fuzz.pdf>https://cfp.recon.cx/media/tz_apps_fuzz.pdf</a></p><p><a href=%5BRECON%20Montreal%202019%5D%20The%20Road%20to%20Qualcomm%20TrustZo%20ace3d28bcbd94d658c3afa71e63193f5/tz_apps_fuzz.pdf>tz_apps_fuzz.pdf</a></p></li></ul><h1 id=abstract>Abstract</h1><p>作者的目标是对trustlet的command handler函数进行AFL测试。</p><p>作者设计了一个loader程序，可以在Android设备的normal world加载并运行trustlet。为了解决syscall的处理问题，作者向QSEOS中加载修补过的trustlet副本作为proxy trustlet。为了能够加载被修补过的代码，作者利用了两个1day漏洞来绕过QSEOS对trustlet的的校验流程。最终使用AFL测试工具完成了测试。</p><h1 id=backguard>Backguard</h1><ul><li><p>secapp range：cmblib库和所有的trustlet都被加载到物理内存中的一个名为secure app region的区域内。该区域的地址可以从Android dmesg日志中找到</p><p><img src=/images/%5BRECON%20Montreal%202019%5D%20The%20Road%20to%20Qualcomm%20TrustZo%20ace3d28bcbd94d658c3afa71e63193f5/Untitled.png alt=Untitled></p></li><li><p>trustlet的内存空间无法被别的trustlet访问</p></li><li><p>trustlet的内存分配请求将被在这个trustlet自身的数据段中进行</p></li><li><p>trustlet的栈区域是trustlet的数据段区域(data segment region)的一部分</p></li><li><p><code>R9</code>寄存器始终指向该trustlet的数据段的初始地址</p></li><li><p>trustlet的command handler函数签名：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#66d9ef>__fastcall</span> <span style=color:#a6e22e>cmd_handler</span>(<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>__int8</span> <span style=color:#f92672>*</span>in, <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> in_size, 
</span></span><span style=display:flex><span>														<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>__int8</span> <span style=color:#f92672>*</span>out, <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> out_size)
</span></span></code></pre></div><p><img src=/images/%5BRECON%20Montreal%202019%5D%20The%20Road%20to%20Qualcomm%20TrustZo%20ace3d28bcbd94d658c3afa71e63193f5/Untitled%201.png alt="一个command handler函数的例子"></p><p>一个command handler函数的例子</p></li></ul><h1 id=在普通世界中运行ta>在普通世界中运行TA</h1><h2 id=基本思路>基本思路</h2><p>创建一个运行在normal world用户态的程序（<strong>trustlet loader</strong>），它：</p><ul><li>分配一段rwx权限的内存区域存储trustlet的代码段和数据段。这些内存块的虚拟地址必须与之前观察到的secapp区域的段地址相同</li><li>将dump出来的段的内容加载到分配出的内存中。</li><li>准备好缓冲区，用于存储trustlet的command handler的输入和输出</li><li>将R9寄存器指向数据段的地址，并调用trustlet的command handler函数</li></ul><h2 id=失败原因>失败原因：</h2><ul><li><strong>依赖于cmnlib</strong>：command handler在执行过程中调用了来自cmnlib的库函数。</li><li><strong>系统调用</strong>：command handler使用<code>SVC</code>指令调用了QSEOS相关的系统调用，但是Linux Kernel并不能处理这种系统调用</li></ul><h2 id=待解决问题>待解决问题：</h2><ol><li>如何获取安全世界中，trustlet和cmnlib的基地址</li><li>如何dump trustlet和cmnlib的数据段</li><li>如何能在normal world执行trustlet中的syscall</li></ol><h2 id=解决方案>解决方案</h2><p><img src=/images/%5BRECON%20Montreal%202019%5D%20The%20Road%20to%20Qualcomm%20TrustZo%20ace3d28bcbd94d658c3afa71e63193f5/Untitled%202.png alt=Untitled></p><h3 id=修补加载到安全世界中的trustlet>修补加载到安全世界中的trustlet</h3><p>通过字节码修补创建一个proxy trustlet。扩展现有trustlet的command handler函数，增加一个自定义的command ID，例如0x99，这个command ID所提供的服务是：</p><ol><li>返回trustlet的基地址</li><li>从secapp区域中读取内存</li><li>向secapp区域中写入内存</li><li>执行一个请求指定的的syscall</li></ol><p>前三个自定义功能，能够帮助我们获得cmnlib的数据段地址（例如对于prov这个trustlet，cmnlib的数据段地址被存储在0x83D4偏移处，这种方法是通用的、每个trustlet都可以访问cmblib的内存）。</p><p><img src=/images/%5BRECON%20Montreal%202019%5D%20The%20Road%20to%20Qualcomm%20TrustZo%20ace3d28bcbd94d658c3afa71e63193f5/Untitled%203.png alt="新的command ID的处理代码，提供了上面提到的那些功能"></p><p>新的command ID的处理代码，提供了上面提到的那些功能</p><h3 id=重定向syscall>重定向syscall</h3><p>修改qemu，使其能够特殊处理<code>SVC 0x1400</code>和<code>SVC 0x14F9</code>，将normal world发来的syscall转发到proxy trustlet里。</p><h3 id=栈地址不一致问题>栈地址不一致问题</h3><p>在设计之初，normal world的trustlet和secure world的proxy trustlet具有不同的栈地址，本质是loader并没有为调用cmd_handler()设置独立的栈地址。这对于程序的运行没有影响，但是由于syscall的参数可能包含指向用户空间栈上内容的指针。为了确保QSEOS在处理syscall时能够访问到正确的数据，必须在secapp地址范围内为cmd_handler()初始化一个栈，它们都能访问到的地址范围。解决办法是由loader扩展trustlet的数据段（data segment），在跳转到command handler之前，先将loader的SP寄存器指向数据段的末尾。</p><h3 id=对prov这个trustlet具体的修补>对<em>prov这个trustlet</em>具体的修补</h3><ul><li><p>增加代码</p><ol><li><p>将代码段的长度从0x6ED0扩展到0x7000</p></li><li><p>将0x99这个command ID的处理代码机器指令写入到0x6ED0</p></li><li><p>将0x2060处的4个字节替换成<code>BL 0x6ED0</code>，即跳到新加入的command ID的处理代码处</p><p><img src=/images/%5BRECON%20Montreal%202019%5D%20The%20Road%20to%20Qualcomm%20TrustZo%20ace3d28bcbd94d658c3afa71e63193f5/Untitled%204.png alt="跳转到command handler的代码"></p><p>跳转到command handler的代码</p></li></ol></li><li><p>为栈腾出空间</p><ol><li>将数据段的长度从0x103F0扩展到0x11000（多出的部分作为栈）</li></ol></li></ul><h2 id=如何加载运行修补后的proxy-trustlet>如何加载运行修补后的proxy trustlet？</h2><h3 id=从启动流程来看>从启动流程来看</h3><p><code>Primary Bootloader(PBL, in ROM)</code> →<code>Secondary BootLoader(SBL)</code>→<code>Little Kernel applications bootloader && QSEOS</code>-><code>trustlets</code></p><p>即使unlock bootloader或者取得root权限也无法打破该流程。</p><h3 id=使用漏洞>使用漏洞</h3><p>使用两个1-day漏洞CVE-2015-6639、CVE-2016-2431，从而作者得以修改Nexus 6设备上的QSEOS的数据段。作者攻击了QSEOS的验证机制。具体来说：</p><ul><li>QSEOS先验证TA文件中的签名数据是否正确，然后再计算各个段的hash值与记录值进行比较。</li><li>作者利用代码注入的方式在签名验证通过后，验证hash值前，改写记录的hash值，从而绕过检查。</li></ul><p><img src=/images/%5BRECON%20Montreal%202019%5D%20The%20Road%20to%20Qualcomm%20TrustZo%20ace3d28bcbd94d658c3afa71e63193f5/Untitled%205.png alt=Untitled></p><h1 id=fuzzing-of-trusted-app>Fuzzing of trusted app</h1><p>到此为止，作者在Android上结合qemu通过模拟的方式运行了一个trustlet的command handler。另外将一个被修补过的trustlet副本作为proxy trustlet加载到真实的QSEOS中。</p><p>使用AFL工具测试TA的command handler，并在安装最新rom的Nexus 6设备上发现了prov这个teustlet的一个漏洞。</p><h1 id=测试别的设备上的trustlet>测试别的设备上的trustlet</h1><p>在Nexus6上运行新的设备上的trustlet，所要付出的努力，比在新设备中利用类似的QSEOS漏洞来创建这样的测试环境要简单的多。</p><p>作者提出了两种测试方法：</p><ol><li>重用之前的由prov这个trustlet修补成的proxy trustlet，作为新的trustlet在QSEOS中的代理</li><li>以每个新的trustlet作为基础进行修补产生proxy trustlet，加载到QSEOS中作为代理</li></ol><p>作者使用第二种方法，通过改编LG和三星设备中的trustlet，然后将其在Nexus6上部署，测试发现了额外的几个漏洞：</p><blockquote><p><em>dxhdcp2</em> (LVE-SMP-190005), <em>sec_store</em> (SVE-2019-13952), <em>authnr</em> (SVE-2019-13949) and <em>esecomm</em> (SVE-2019-13950), <em>kmota</em> (CVE-2019-10574), <em>tzpr25</em> (acknowledged by Samsung), <em>prov</em> (Motorola is working on a fix).</p></blockquote></main><div id=comments><hr><script src=https://utteranc.es/client.js repo=KB5201314/KB5201314.github.io issue-term=pathname label='💬 comments 💬' theme=github-light crossorigin=anonymous async></script></div><footer class=footer><hr>© imlk 2017 &ndash; 2023 | <a href=https://blog.imlk.top>imlk's blog</a> | <a href=https://github.com/KB5201314/>Github</a> | <a href=mailto:me@imlk.top>Email</a> | <a href=https://beian.miit.gov.cn/>京ICP备2020042968号-1</a></footer></body></html>