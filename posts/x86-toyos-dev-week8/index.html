<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>自制x86玩具操作系统 week8 | imlk's blog</title><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=/css/fonts.css><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@400;700&display=swap" rel=stylesheet></head><body><header class=header><a class=logo href=/>imlk's Blog</a><nav><ul class=menu><li><a href=/>🏠Home</a></li><li><a href=/about/>👋About</a></li><li><a href=/archives/>📜Archives</a></li><li><a href=/friends/>🔗Friends</a></li><li><a href=/dn42/>🕸️DN42</a></li><li><a href=/index.xml>📢Subscribe</a></li></ul></nav></header><hr><div class=article-meta><h1><span class=title>自制x86玩具操作系统 week8</span></h1><span><span class=date>📅 2019-05-01</span>
<span class=date>(更新于2021-10-10)</span>
/
<span class=cats>📚
<a href=https://blog.imlk.top/categories/osdev/>OSDev</a></span>
/
<span class=tags>🏷️
<a href=https://blog.imlk.top/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/>#操作系统</a>
<a href=https://blog.imlk.top/tags/diy/>#DIY</a></span></span><br></div><main><h2 id=day-0x17>DAY 0x17</h2><h4 id=关于链接器obj2bim>关于链接器obj2bim</h4><p>翻看源码发现，obj2bim其实就是个链接器，依据一个.rul规则文件来生成链接后的二进制文件。</p><h5 id=输入文件>输入文件</h5><p>它接受的输入文件有obj和lib这两种文件，其中lib文件也有两种，一种是标准的pe文件，有一种是作者自定义的格式，在链接前会decode成标准的lib文件，然后从lib文件解压出obj文件来进行处理，所以这个链接器主要进行的是对obj文件的处理。
例如haribote / golibc.lib就是作者自定义的一种格式的文件，它原本是一个标准的win下的lib文件，编写工具将其转换出来后发现里头并没有什么有意思的东西，只是几个字符串相关的处理函数的实现。</p><h5 id=处理obj>处理obj</h5><p>处理过程在<code>loadobj</code>函数中，主要是用一个全局的数组存储所有的obj文件对象。</p><ul><li>数据拷贝
对于每个obj，将各个段依次解析，拷贝其中的数据到一片开辟的空间中。</li><li>重定位表处理
对于每个段，都开辟了一块空间存储重定位表的表项数组，然后解析每个段指向的<code>relocation table</code>重定位表，obj文件中重定位表的结构如下：</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>_IMAGE_RELOCATION</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>union</span> {
</span></span><span style=display:flex><span>		DWORD  VirtualAddress;
</span></span><span style=display:flex><span>		DWORD  RelocCount;
</span></span><span style=display:flex><span>	} M;
</span></span><span style=display:flex><span>	DWORD  SymbolTableIndex;
</span></span><span style=display:flex><span>	WORD Type;
</span></span><span style=display:flex><span>} IMAGE_RELOCATION;
</span></span></code></pre></div><p>其中<code>VirtualAddress</code>指向的是需要被重定位的位置相对于当前段的偏移量。
每个重定位表项有一个指向符号表的索引号，这部分操作总的来说就是把重定位表里面的项解析成程序中的结构，最后把重定位表的第一个元素的指针以及重定位表项的数目记录到obj中的对应的段中</p><ul><li>符号表
处理完段以后，处理符号表，排除一些符号比如调试用的符号，然后加载到之前的符号数组里，同时把bss段进行对齐。
符号表中包含两种组成，一种是定义在外部的符号，一种是定义在本obj文件的符号。
obj2bim这个链接器进程维护了一个包含所有符号的数组（相当于一个巨大的符号表），对于符号表中的每一项，先到该符号数组中去查找，如果找不到就添加一个新的符号。
每个符号项在程序中还带有一个指针，指向定义它的obj结构体实例，从而最终能区分一个符号是否被定义。
obj文件中符号表项的结构如下：</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>_IMAGE_SYMBOL</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>union</span> {
</span></span><span style=display:flex><span>		BYTE    ShortName[<span style=color:#ae81ff>8</span>];
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>			DWORD   Short;     <span style=color:#75715e>// if 0, use LongName
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			DWORD   Long;      <span style=color:#75715e>// offset into string table
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		} Name;
</span></span><span style=display:flex><span>		DWORD   LongName[<span style=color:#ae81ff>2</span>];  <span style=color:#75715e>//two byte potioner
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	} N;
</span></span><span style=display:flex><span>	DWORD   Value;
</span></span><span style=display:flex><span>	SHORT   SectionNumber;
</span></span><span style=display:flex><span>	WORD    Type;
</span></span><span style=display:flex><span>	BYTE    StorageClass;
</span></span><span style=display:flex><span>	BYTE    NumberOfAuxSymbols;
</span></span><span style=display:flex><span>} IMAGE_SYMBOL;
</span></span></code></pre></div><h5 id=开始链接>开始链接</h5><ul><li><p>处理指定的label
加载完所有的obj以后，读取rul文件中的<code>label</code>字段，然后读取rul文件中指定的符号，如果找不到就会报错。
之后遍历所有的符号，对用到的符号进行标记。</p></li><li><p><strong>预链接</strong>
预处理完以后，三次调用<code>link0()</code>函数依次收集所有obj的代码段、所有obj的数据段、所有obj的bss段，组成三个大段。
收集过程中，将数据填充到<code>filebuf</code>中，根据rul文件中规定的每个大段的起始逻辑地址算出obj中每个段的的逻辑地址，以便后面符号的确定时使用，最后计算出这三个大段的逻辑地址的结束位置</p></li><li><p><strong>符号值的确定</strong>
重定位主要是因为编译时单个obj不能确定代码所在的地址，要到链接时把所有obj放到一起才能确定符号的位置，而符号代表的就是地址，所以，我们要把符号的值进行修改。
具体操作是：<strong>每个符号原先的偏移量（符号表示的值）加上上一步计算出的它所在的obj文件的对应段的逻辑地址，变成该符号（表示的值）的逻辑地址</strong></p></li><li><p>输出map文件（可选）
然后开始输出.map文件，输出三种段的大小以及处理过的全局的符号表（符号的逻辑地址和符号的字符串表示，吐槽一下作者由于不会写按地址进行排序函数，用了一种很慢的办法来排序）</p></li><li><p><strong>link</strong>
这样搞了一通以后下面就是真的link过程了，之前已经把符号的值重新计算过了，现在就是要<strong>把符号的值应用到要重定位的地方</strong>。
其实代码中每个需要重定位的语句都会在重定位表里面生成一项。
这个link过程其实就是对重定位表项的处理，由于上面的上面一步中已经处理出了符号（表示的值）的逻辑地址了，那这里<strong>只需要在每个重定位表项里面把<code>VirtualAddress</code>处的值改成对应的符号（表示的值）就行了</strong>（注意这里不一定是直接写入符号的值（逻辑地址），因为有的指令比如call指令可能接受的不是绝对地址，而是相对于pc值的地址）。</p></li></ul><h5 id=输出>输出</h5><p>最后输出作者规定的一种格式的文件，将代码段和数据段的信息（大小，文件中的位置，逻辑地址）写到文件起始位置。
接下来是是写入了rul文件中指定的那个label符号表示的值（在文件中偏移量为24的位置）。例如rul中<code>label</code>项写的是<code>_HariStartup</code>，那么就是把<code>_HariStartup</code>符号的入口地址写到这了。
然后是在指定的位置写入了代码段和数据段的内容，至此链接过程完成。</p><h5 id=一些思考>一些思考</h5><ul><li>重定位的时候究竟改了什么？
代码中有一个让我很疑惑的地方，就是在"link"步骤的时候，往<code>VirtualAddress</code>写东西（4字节）时，作者刻意用了小端模式的写法，而之前各个地方赋值的时候，都没有刻意用小端，为了探查究竟，用工具来解析一下这所谓的重定位表，
这是<code>bootpack.obj</code>中<code>HariMain</code>函数的一部分汇编。</li></ul><pre tabindex=0><code>0000047a &lt;_HariMain&gt;:
 ...
 480:   81 ec dc 00 00 00       sub    $0xdc,%esp
 486:   e8 00 00 00 00          call   48b &lt;_HariMain+0x11&gt;	; 这里
 48b:   e8 00 00 00 00          call   490 &lt;_HariMain+0x16&gt;
 490:   e8 00 00 00 00          call   495 &lt;_HariMain+0x1b&gt;
 495:   e8 00 00 00 00          call   49a &lt;_HariMain+0x20&gt;
 49a:   c7 44 24 04 f8 00 00    movl   $0xf8,0x4(%esp)
 ...
</code></pre><p>注意<code>0x486</code>那里第一个<code>call</code>汇编应该是</p><pre tabindex=0><code>call    __Z7init_dtv    ; init_dt(void)`
</code></pre><p><code>init_dt(void)</code>应该是<code>dsctbl.obj</code>中的导出函数，</p><p>再看解析出来的重定位表的一部分</p><pre tabindex=0><code>                                                Symbol    Symbol
 Offset    Type              Applied To         Index     Name
 --------  ----------------  -----------------  --------  ------
 ...
 00000487  REL32                      00000000        35  __Z7init_dtv
 ...
</code></pre><p>表中<code>__Z7init_dtv</code>这个符号的<code>Offset</code>是<code>00000487</code>，这是什么意思呢？
注意看上面汇编中，<code>0x486</code>的那条<code>call</code>指令，长度为5个字节，后面从<code>0x487</code>开始的四个字节都是十六进制的<code>00</code>，我们可以大胆的猜测，这应该是留空给链接器填入链接后的地址的。</p><blockquote><p>事实上查阅i386汇编手册就可以知道，这是<code>call</code>指令的一种五字节长的版本，在<code>0xE8</code>后面接四字节的相对地址构成一条<code>call</code>指令，这对链接器来说就很方便了，不知道对于其它架构的机器码链接器是怎么做链接的。</p></blockquote><p>也就是说，最后我们把<code>__Z7init_dtv</code>的地址填到这里就能<code>call</code>了吧？其实不是这样的啦，<code>call</code>需要的是相对地址，所以链接器得先根据重定位表中该项的<code>type</code>进行个判断，<strong>把符号的值减去（当前指令的地址+4）的值</strong>写入到这个<code>call</code>语句中，所以说，链接时的重定位是要修改<code>.text</code>段的。</p><p>同理，</p><pre tabindex=0><code>mov     dword ptr ds:__ZN3sys8memtotalE, eax ; sys::memtotal
</code></pre><p>对应的是</p><pre tabindex=0><code>4e4:   a3 00 00 00 00          mov    %eax,0x0
</code></pre><p>这里指令中也有四字节的空间是留出来让链接器时重定位<code>__ZN3sys8memtotalE</code>这个外部引用用的</p><ul><li>关于.bss段
全局变量存到.bss段里头，而这个段比较特殊，只在段的header里面存储它的大小，在运行加载时才为其初始化空间，但是显然裸机是不会帮我们分配<code>.bss</code>段的，而且这个操作系统我们还没有写加载器，那<code>.bss</code>段只能由这个静态链接器来展开了，验证一番发现在<code>link0</code>里面对<code>.bss</code>段腾出了空间的逻辑。</li></ul><h4 id=关于bim2hrb>关于bim2hrb</h4><p>bim2hrb对比obj2bim就简单的多了，只是把bim的前面若干个字节进行了一些变动，加上了堆的空间的指定，然后调整了一下开头处存储的地址和大小什么的数据，还在前面加上了作者自己的魔术字<code>Hari</code>。</p><h4 id=参考>参考</h4><ul><li>Intel call指令
<a href=https://www.cnblogs.com/scu-cjx/p/6879041.html>https://www.cnblogs.com/scu-cjx/p/6879041.html</a></li><li>PE格式第七讲,重定位表
<a href=https://www.cnblogs.com/iBinary/p/7690069.html>https://www.cnblogs.com/iBinary/p/7690069.html</a></li><li>[原创]010edit模版(obj文件分析)
<a href=https://bbs.pediy.com/thread-222934.htm>https://bbs.pediy.com/thread-222934.htm</a></li></ul><h4 id=异常中断>异常中断</h4><p>x86中，从0x00到0x1f都是异常所使用的中断，IRQ的中断号都是从0x20之后开始的。
0x00 除零异常（当试图除以0时产生）
0x0c 栈异常
0x0d 非法内存访问
0x06 非法指令异常（当试图执行CPU无法理解的机器语言指令， 例如当试图执行一段数据时，有可能会产生）</p></main><div id=comments><hr><script src=https://utteranc.es/client.js repo=KB5201314/KB5201314.github.io issue-term=pathname label='💬 comments 💬' theme=github-light crossorigin=anonymous async></script></div><footer><hr>© imlk 2017 &ndash; 2021 | <a href=https://blog.imlk.top>imlk's blog</a> | <a href=https://github.com/KB5201314/>Github</a> | <a href=mailto:me@imlk.top>Email</a> | <a href=https://beian.miit.gov.cn/>京ICP备 - 2020042968号</a></footer></body></html>