<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>使用Yubikey PIV和PKCS#11来验证SSH Client | imlk's blog</title><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=/css/fonts.css><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@400;700&display=swap" rel=stylesheet></head><body><header class=header><a class=logo href=/>imlk's Blog</a><nav><ul class=menu><li><a href=/>🏠Home</a></li><li><a href=/about/>👋About</a></li><li><a href=/archives/>📜Archives</a></li><li><a href=/friends/>🔗Friends</a></li><li><a href=/dn42/>🕸️DN42</a></li><li><a href=/index.xml>📢Subscribe</a></li></ul></nav></header><hr><div class=article-meta><h1><span class=title>使用Yubikey PIV和PKCS#11来验证SSH Client</span></h1><span><span class=date>📅 2023-03-16</span>
/
<span class=cats>📚
<a href=https://blog.imlk.top/categories/security/>Security</a></span>
/
<span class=tags>🏷️
<a href=https://blog.imlk.top/tags/yubikey/>#Yubikey</a>
<a href=https://blog.imlk.top/tags/pkcs11/>#PKCS11</a></span></span><br></div><main class=post-content><p>前段时间抽空给自己的“Homelab”服务器加了内存，能开更多的VM & Conteiner了。虽然用Tailscale和自建Headscale/Derper服务的方式组了内网，访问服务器上的服务的时候也都是走的内网，一定程度上通信链路上是安全了。但是目前还是一个ssh key到处用，如果笔记本失窃/密钥被读走了，还是很危险的，(说起来之前用Termius就是自动把<code>~/.ssh/</code>里的所有key都上云了)。所以这次借着升级配置的这个机会，把手里的Yubikey的PIV功能给用上，让ssh server能够用Yubikey里存的私钥来验证ssh client。</p><h1 id=证书生成与导出>证书生成与导出</h1><p>基本上是参考了Yubikey Handbook里的<a href=https://ruimarinho.gitbooks.io/yubikey-handbook/content/ssh/authenticating-ssh-with-piv-and-pkcs11-client/>Authenticating SSH with PIV and PKCS#11 (client)</a>这篇文章，下面的内容也是基于这篇文章来说明。</p><ol><li><p>首先在yubikey中生成一对RSA 2048密钥，并生成一个自签名证书，这个可以选择用<code>yubico-piv-tool</code>命令行工具，也可以用<code>Yubikey Manager</code>这个GUI工具，我选择了后者。</p><p>这里除了能够生成自签名证书，还可以选择生成CSR(certificate signing request)，我想应该是为了方便让CA签证书的场景。之前也考虑过自建CA的事，不过感觉麻烦就搁置了。</p></li><li><p>从证书中导出公钥，保存到<code>~/.ssh/ybk_piv.pub</code>里(文件名任意)</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>ssh-keygen -D /usr/lib/opensc-pkcs11.so -e &gt; ~/.ssh/ybk_piv.pub
</span></span></code></pre></div></li></ol><h1 id=服务端配置>服务端配置</h1><p>将该公钥安装到目标sshd服务器的<code>~/.ssh/authorized_keys</code>里</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>ssh-copy-id -f -i ~/.ssh/ybk_piv.pub &lt;user&gt;@&lt;server-ip&gt;
</span></span></code></pre></div><p>到此，服务端的配置就完成了</p><h1 id=配置客户端环境>配置客户端环境</h1><p>PKCS#11是一套为应用程序使用HSM执行密码函数而定义的API标准，也称为Cryptoki(Cryptographic token interface)。</p><p><a href=https://en.wikipedia.org/wiki/OpenSC>OpenSC</a>是PKCS#11的一个实现，而它可以使用<a href=https://en.wikipedia.org/wiki/PC/SC>PC/SC</a>作为后端。后者是一种将智能卡集成到计算环境中的规范，在Linux上的实现者为<a href=https://github.com/LudovicRousseau/PCSC>pcsclite</a>。<a href=https://en.wikipedia.org/wiki/CCID_(protocol)>CCID</a>是一种USB协议，Yubikey设备支持这种协议。</p><p>在一个新的Linux主机上，要让ssh client使用PKCS#11来验证，至少需要准备以下软件组件，以ArchLinux环境为例</p><ol><li>安装<code>pcsclite</code>并确保<code>pcscd.service</code>正在运行</li><li>安装<code>opensc</code>，这时你将拥有<code>/usr/lib/opensc-pkcs11.so</code>和<code>pkcs11-tool</code></li><li>安装<code>ccid</code></li></ol><p>这时运行<code>pkcs11-tool -L</code>你应该能看到你的Yubikey并且其中有一个solt。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-txt data-lang=txt><span style=display:flex><span>➜  ~ pkcs11-tool -L   
</span></span><span style=display:flex><span>Available slots:
</span></span><span style=display:flex><span>Slot 0 (0x0): Yubico YubiKey OTP+FIDO+CCID 00 00
</span></span><span style=display:flex><span>  token label        : ssh
</span></span><span style=display:flex><span>  token manufacturer : piv_II
</span></span><span style=display:flex><span>  token model        : PKCS#15 emulated
</span></span><span style=display:flex><span>  token flags        : login required, rng, token initialized, PIN initialized
</span></span><span style=display:flex><span>  hardware version   : 0.0
</span></span><span style=display:flex><span>  firmware version   : 0.0
</span></span><span style=display:flex><span>  serial num         : xxxxxxxxxxxxxxxx
</span></span><span style=display:flex><span>  pin min/max        : 4/8
</span></span></code></pre></div><p>如果没有，请排查上述服务/软件包，并检查lsusb和udev配置。</p><h1 id=配置客户端openssh-client>配置客户端openssh client</h1><p>遗憾的是支持PKCS#11密钥的ssh client并不多，实测Termius并没有此功能，但是看介绍xshell好像支持的。但是一般来说咱们也就用openssl client了所以这里以它为例。</p><p>这里有两种选择，一种是在每次开机后用<code>ssh-add</code>主动将密钥添加到ssh-agent里</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>ssh-add -s /usr/lib/opensc-pkcs11.so
</span></span></code></pre></div><p>优点是只需要在添加的时候输入一次PIN码，之后（注销之前）再插拔yubikey不需要再次输入。（为啥我觉得这不算是什么优点反而是缺点）</p><p>另一种则是在<code>~/.ssh/config</code>里配置<code>PKCS11Provider</code>。比如下面的配置给所有的Host在登陆时都尝试使用yubikey上的密钥</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-txt data-lang=txt><span style=display:flex><span>Host *
</span></span><span style=display:flex><span>	PKCS11Provider /usr/lib/opensc-pkcs11.so
</span></span></code></pre></div><p>在这种配置下在每次ssh登陆的时候都会让你输一次PIN码（<del>是不是感觉安全了很多？</del> 其实并不，如果输过一次了只要按一下回车就可以过，除非拔掉yubikey再插才会再问你要密码）</p><h1 id=和identitiesonly-yes一起使用>和<code>IdentitiesOnly yes</code>一起使用</h1><p>一般来说咱们还是习惯给不同的服务器配置不同的密钥的，这也导致我们在<code>~/.ssh/</code>里会有一大坨密钥。ssh-agent也会悉数将其收入，然后在连接ssh server的时候挨个尝试，结果就导致<code>Too many authentication failures</code>出现， 所以openssh提供了<code>IdentitiesOnly yes</code>这个配置避免这个问题，在这种情况下对于<code>~/.ssh/config</code>里的每个Host，只会尝试由<code>IdentityFile</code>指定的key。如果这个Host没有指定的话就尝试<code>~/.ssh/id_rsa</code>之类的默认密钥路径。</p><p>但是openssl在处理的时候似乎有一点bug，当<code>IdentitiesOnly yes</code>和<code>PKCS11Provider</code>同时存在时，后者会被忽略。根据<a href=https://groups.google.com/g/opensshunixdev/c/jD1pghvajpo>这里</a>的讨论，<code>IdentityFile</code>相当于一个filter，只会尝试<code>IdentityFile</code>指定的那些公钥， 因此一个解决办法是加一个<code>IdentityFile</code>指向我们之前从yubikey里导出的公钥，完整例子如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-txt data-lang=txt><span style=display:flex><span>Host *
</span></span><span style=display:flex><span>	IdentitiesOnly yes
</span></span><span style=display:flex><span>	PKCS11Provider /usr/lib/opensc-pkcs11.so
</span></span><span style=display:flex><span>	IdentityFile ~/.ssh/ybk_piv.pub
</span></span></code></pre></div><h1 id=闲聊>闲聊</h1><p>其实不管是普通的ssh密钥文件还是这篇文章中提到的PIV，都是对ssh client侧的验证。那么对ssh server侧的验证又如何呢？</p><p>在ssh client第一次连接到一个新的ssh server时，会显示server侧公钥的<code>fingerprint</code>，并且问你：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-txt data-lang=txt><span style=display:flex><span>Are you sure you want to continue connecting (yes/no/[fingerprint])? 
</span></span></code></pre></div><p>这时候如果你信任这个网络环境，或者你比对过这个fingerprint是对的，你可以直接yes，然后它会把server的公钥加到<code>~/.ssh/known_hosts</code>里面。或者你可以输入一个指纹比如<code>SHA256:CB5smnwKhpcnT1bz6OXHYuFcijlMS3nw2tEJ2HoR++A</code>之类的，接着它会帮你比对。当之后你连接到server时，如果这时发生了中间人攻击，那么ssh client能够根据<code>~/.ssh/known_hosts</code>中的公钥比对失败来检测到。这就是所谓的<a href=https://en.wikipedia.org/wiki/Trust_on_first_use>Trust on first use (TOFU)</a>的方式。</p><p>所以（在最常见的配置情况下）对ssh server的验证关键在第一次连接时。ssh client把责任交给了用户，它假设你能够根据额外的可信信息源来确认这个fingerprint（因为第一次连接的时候没有信任锚，之后的信任锚在<code>~/.ssh/known_hosts</code>里）。</p><p>但是在大多数情况下，我们忽略了这一步，直接yes掉。假设一个足够强大的攻击者（比如所在单位的网络管理员、运营商级、<del>甚至country级</del>的劫持），能够在你第一次连接这个服务器时就篡改你的数据包做MITM攻击，并且对于之后的连接都能够劫持并篡改（防止因为fingerprint变动而被受害者察觉到MITM的存在），那如果你没有手动和server上的fingerprint比对，至始至终你的ssh会话都是透明的。</p><p>到这里，是不是感觉ssh其实也没有那么的安全，毕竟你大概率也没有真正比对过你<del>海外的某台VPS</del>服务器上的fingerprint对吧（笑）。如果你想现在做一下验证，<a href=https://www.phcomp.co.uk/Tutorials/Unix-And-Linux/ssh-check-server-fingerprint.html>这篇文章</a>里提到了在server端计算fingerprint的几个命令，你可以用它来和ssh连接时的指纹进行比对。最好经过可信的方式登陆到服务器并运行这些命令，如经过云服务商的VNC控制台/更为可信的网络环境/隧道/<code>ssh -J</code>等，以防御对终端输出内容进行匹配替换的攻击者（不过真的有人会这么做吗）。</p><p>突然想到，整个世界好像就是在“各式各样的草台班子”和“自欺欺人般的信任”中运转的。</p><p>完。</p></main><div id=comments><hr><script src=https://utteranc.es/client.js repo=KB5201314/KB5201314.github.io issue-term=pathname label='💬 comments 💬' theme=github-light crossorigin=anonymous async></script></div><footer class=footer><hr>© imlk 2017 &ndash; 2023 | <a href=https://blog.imlk.top>imlk's blog</a> | <a href=https://github.com/KB5201314/>Github</a> | <a href=mailto:me@imlk.top>Email</a> | <a href=https://beian.miit.gov.cn/>京ICP备 - 2020042968号</a></footer></body></html>