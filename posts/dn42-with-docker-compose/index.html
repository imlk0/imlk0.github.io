<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>在Docker Compose中部署你的DN42节点 | imlk's blog</title><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=/css/fonts.css><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@400;700&display=swap" rel=stylesheet></head><body><header class=header><a class=logo href=/>imlk's Blog</a><nav><ul class=menu><li><a href=/>🏠Home</a></li><li><a href=/about/>👋About</a></li><li><a href=/archives/>📜Archives</a></li><li><a href=/friends/>🔗Friends</a></li><li><a href=/dn42/>🕸️DN42</a></li><li><a href=/index.xml>📢Subscribe</a></li></ul></nav></header><hr><div class=article-meta><h1><span class=title>在Docker Compose中部署你的DN42节点</span></h1><span><span class=date>2022-02-23</span>
<span class=date>(更新于2022-08-22)</span>
/
<span class=cats><a href=https://blog.imlk.top/categories/network/>Network</a></span>
/
<span class=tags><a href=https://blog.imlk.top/tags/dn42/>#DN42</a>
<a href=https://blog.imlk.top/tags/bgp/>#BGP</a>
<a href=https://blog.imlk.top/tags/docker/>#Docker</a></span></span><br></div><main><p>其实这篇文章攒了很久一直没有写，其中一个原因是DN42的入门教程太多了，再发也就重复了。但是又很想写点东西毕竟这个也折腾了一段时间，于是在某个夜深人静的夜晚，<del>不想干活</del>无所事事的我决定整理一下水一篇:)。</p><h1 id=初见dn42>初见DN42</h1><p>我大概是去年冬天的时候入坑了DN42，主要是看MiaoTony和Lan Tian的blog去注册。然后由于当时受到某位好友的「All in docker-compose.yaml」文化的感染，我萌生了把DN42的服务用docker-compose脚本去定义的想法。</p><h1 id=dn42-with-docker-compose>DN42 with docker-compose</h1><p>基于docker-compose有这么一些好处：</p><ol><li>安全性。通常来说，dn42教程里会需要你在主机上执行包括关闭防火墙之类的操作。使用docker-compose方案可以避免这一问题，同时将主机上的其它私有服务与dn42网络做隔离。</li><li>方便扩展dn42节点。只需要rsync到新的机器上，改改配置就能开一个新的Route Server。</li><li>配置错误后随时remake。<code>docker down && docker up</code>又是全新的一天。</li><li>可以在docker-compose.yaml里直接完成ip地址的静态分配，结合<a href=https://docs.docker.com/compose/compose-file/#ipam>IPAM</a>，可以为不同的Route Server划分地址段。</li></ol><p>也有这么一些缺点：</p><ol><li>网络变得复杂：我们的设想是把在docker中定义一个bridge网络，所有的bgp、dns、lookingglass等dn42服务全部挂到这个bridge网络上。</li><li>有一些坑：当然我基本上都帮你填好了。</li></ol><p>那么话不多说，我将代码放入到了这个仓库里 👉 <a href=https://github.com/KB5201314/dn42-stuffs>dn42-stuffs</a></p><p>由于每个人的口味不同，建议您clone下来之后按照自己的意愿去修改</p><blockquote><p>对了我的ASN是<code>4242421742</code>，欢迎联系我peer（太懒了没写自动peer服务，要是有人捐赠一个Pull Request给咱就好了）</p></blockquote><h1 id=一些排错经验>一些排错经验</h1><h2 id=使用ip6tables追踪数据包>使用ip6tables追踪数据包</h2><h3 id=设置追踪>设置追踪</h3><p>可以直接参考<a href=https://sleeplessbeastie.eu/2020/11/13/how-to-trace-packets-as-they-pass-through-the-firewall/>这篇文章</a>，在raw表上的<code>PREROUTING</code>或者<code>OUTPUT</code>表上设置<code>-j TRACE</code>。</p><p>比如下面是追踪进入到该主机的icmpv6包：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>ip6tables -t raw -A PREROUTING -p icmpv6 -j TRACE
</span></span></code></pre></div><h3 id=查看追踪日志>查看追踪日志</h3><p>旧版内核通常使用<code>modprobe ipt_LOG</code>，例如<a href=https://www.opsist.com/blog/2015/08/11/how-do-i-see-what-iptables-is-doing.html>这里</a>所介绍的。</p><p>但是由于博主的kernel比较新，现在使用<code>nf_log_*</code>系列模块：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>modprobe nf_log_ipv6
</span></span><span style=display:flex><span>sysctl net.netfilter.nf_log.10<span style=color:#f92672>=</span>nf_log_ipv6
</span></span></code></pre></div><p>需要注意的是<code>nf_log.</code>后面的数字实际上对应着协议编号，具体值是取决于代码中定义的，比如我们想观察的ipv6协议对应<code>AF_INET6</code>的值为<code>10</code>，而ipv4对应的<code>AF_INET</code>值为2。这下netfiliter框架会将trace打印到内核消息中。</p><p>查看日志<a href=https://www.opensourcerers.org/2016/05/27/how-to-trace-iptables-in-rhel7-centos7/>一般的方法</a>都是先配置<code>rsyslog</code>输出日志，然后去看<code>kern.*</code>被输出到的地方，也有直接用<code>dmesg</code>查看的。但是测试发现并不管用，猜测是netns隔离的原因。</p><p>最后在<a href=https://wiki.nftables.org/wiki-nftables/index.php/Ruleset_debug/tracing>nftables官方文档</a>这里找到另一种方法来查看：</p><p>首先必须确保当前的shell处在上面执行<code>ip6table</code>时同一个netns里面，否则看不到日志。</p><p>然后使用nftables查看trace记录：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>nft monitor trace
</span></span></code></pre></div><p>就会显示出<code>-j TRACE</code>的记录。</p><h2 id=排错过程一>排错过程一</h2><p>进行一次从<code>fd42:d2aa:8a0e::3</code> 主机A到 ip为<code>fd42:d42:d42:54::1</code>的目标T的ping6。其中网关G的ip为<code>fd42:d2aa:8a0e::2</code>。</p><p>主机A和网关G均为docker container。</p><p>现象是：echo-request包到达网关G后并没有被转发出来。并且<strong>任何来源的ipv6包网关G都不做转发</strong>。</p><p>在网关G的netns中使用iptables设置追踪：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>ip6tables -t raw -A PREROUTING -p icmpv6 --destination fd42:d42:d42:54::1 -j TRACE
</span></span></code></pre></div><p>追踪日志如下：</p><pre tabindex=0><code>trace id e4a36c57 ip6 raw PREROUTING packet: iif &#34;eth0&#34; ether saddr 02:42:ac:16:60:03 ether daddr 02:42:ac:16:60:02 ip6 saddr fd42:d2aa:8a0e::3 ip6 daddr fd42:d42:d42:54::1 ip6 dscp cs0 ip6 ecn not-ect ip6 hoplimit 64 ip6 flowlabel 668322 ip6 length 64 icmpv6 type echo-request icmpv6 code no-route icmpv6 parameter-problem 27197440 @th,64,96 13911993890790384138924851200 
trace id e4a36c57 ip6 raw PREROUTING rule meta l4proto ipv6-icmp ip6 daddr fd42:d42:d42:54::1 counter packets 19226 bytes 1999504 meta nftrace set 1 (verdict continue)
trace id e4a36c57 ip6 raw PREROUTING verdict continue 
trace id e4a36c57 ip6 raw PREROUTING policy accept 
</code></pre><p>显示packet到<code>PREROUTING</code>之后就消失了，<a href=https://unix.stackexchange.com/questions/690999/ipv6-forwarding-doesnt-work-in-a-network-namespace>查阅资料</a>发现，sysctl的<code>net.*</code>是能够感知netns（network-namespace aware）的，而<strong>在创建container的netns时，<code>net.ipv6.conf.all.forwarding=1</code>设置并未从init_net继承</strong>（该行为由<a href="https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/Documentation/admin-guide/sysctl/net.rst?h=v5.8#n332">net.core.devconf_inherit_init_net</a>控制），因此需要在网关G容器中额外设置开启ipv6的forwarding：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>sysctl -w net.ipv6.conf.all.forwarding<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>
</span></span></code></pre></div><p>设置完成后通过tcpdump发现，echo-request被发出并且目标T返回的echo-reply抵达网关G。</p><h2 id=排错过程二>排错过程二</h2><p>上面的问题解决后，echo-reply抵达了网关G，但是另一个问题是echo-reply并没有被转发给主机A。</p><p>测试发现<strong>任何外面的DN42主机的包都无法进来，简单来说：只出不进。</strong></p><p>在网关G上设置raw表上PREROUTING的trace：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>ip6tables -t raw -A PREROUTING -p icmpv6 --destination fd42:d2aa:8a0e::3 -j TRACE
</span></span></code></pre></div><p>结果显示echo-reply断在了raw表的PREROUTING链上：</p><pre tabindex=0><code>trace id c9fb2605 ip6 raw PREROUTING packet: iif &#34;wg-4242422688&#34; ip6 saddr fd42:d42:d42:54::1 ip6 daddr fd42:d2aa:8a0e::3 ip6 dscp cs0 ip6 ecn not-ect ip6 hoplimit 62 ip6 flowlabel 808330 ip6 length 64 icmpv6 type echo-reply icmpv6 code no-route icmpv6 parameter-problem 11339418 @th,64,96 62617626364244974739948306432 
trace id c9fb2605 ip6 raw PREROUTING rule meta l4proto ipv6-icmp ip6 daddr fd42:d2aa:8a0e::3 counter packets 17107 bytes 1779128 meta nftrace set 1 (verdict continue)
trace id c9fb2605 ip6 raw PREROUTING rule ip6 daddr fd42:d2aa:8a0e::3 counter packets 15984 bytes 1656726 meta nftrace set 1 (verdict continue)
trace id c9fb2605 ip6 raw PREROUTING rule meta l4proto ipv6-icmp ip6 daddr fd42:d2aa:8a0e::3 counter packets 7 bytes 728 meta nftrace set 1 (verdict continue)
trace id c9fb2605 ip6 raw PREROUTING verdict continue 
trace id c9fb2605 ip6 raw PREROUTING policy accept 
</code></pre><p>但是netns中的防火墙规则并未拦截，并且trace也没有显示哪一条规则drop了这个packet。</p><p>排查后发现原因是主机A和网关G均为docker container，它们之间的网络经由docker主机上的bridge相连，因此还受到docker主机上防火墙的影响。</p><p>在docker主机上trace：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>ip6tables -t raw -A PREROUTING -p icmpv6 --destination fd42:d2aa:8a0e::3 -j TRACE
</span></span></code></pre></div><pre tabindex=0><code>trace id 698de359 ip6 raw PREROUTING packet: iif &#34;br-94f3521ab04f&#34; ether saddr 02:42:ac:16:60:02 ether daddr 02:42:ac:16:60:03 ip6 saddr fd42:d42:d42:54::1 ip6 daddr fd42:d2aa:8a0e::3 ip6 dscp cs0 ip6 ecn not-ect ip6 hoplimit 61 ip6 flowlabel 808330 ip6 length 64 icmpv6 type echo-reply icmpv6 code no-route icmpv6 parameter-problem 11339711 @th,64,96 4913746139972088583361134592 
trace id 698de359 ip6 raw PREROUTING rule meta l4proto ipv6-icmp ip6 daddr fd42:d2aa:8a0e::3 counter packets 2 bytes 176 meta nftrace set 1 (verdict continue)
trace id 698de359 ip6 raw PREROUTING verdict continue 
trace id 698de359 ip6 raw PREROUTING policy accept 
trace id 698de359 inet firewalld raw_PREROUTING packet: iif &#34;br-94f3521ab04f&#34; ether saddr 02:42:ac:16:60:02 ether daddr 02:42:ac:16:60:03 ip6 saddr fd42:d42:d42:54::1 ip6 daddr fd42:d2aa:8a0e::3 ip6 dscp cs0 ip6 ecn not-ect ip6 hoplimit 61 ip6 flowlabel 808330 ip6 nexthdr ipv6-icmp ip6 length 64 icmpv6 type echo-reply icmpv6 code no-route icmpv6 parameter-problem 11339711 @th,64,96 4913746139972088583361134592 
trace id 698de359 inet firewalld raw_PREROUTING rule meta nfproto ipv6 fib saddr . iif oif missing drop (verdict drop)
</code></pre><p>结果显示断在了<strong>docker主机上firewalld防火墙的一条规则</strong>上，使用nft查看这条规则：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>sudo nft list chain inet firewalld raw_PREROUTING;
</span></span></code></pre></div><pre tabindex=0><code>table inet firewalld {
        chain raw_PREROUTING {
                type filter hook prerouting priority raw + 10; policy accept;
                icmpv6 type { nd-router-advert, nd-neighbor-solicit } accept
                meta nfproto ipv6 fib saddr . iif oif missing drop
        }
}
</code></pre><p>（没想到host主机上的防火墙会作用在docker的bridge网络上）</p><p>关键在于那行<code>drop</code>语句，是对ipv6数据包的来源地址进行反向检查，检查当前这个包的来源地址是否和，回复该地址时的interface一致。</p><p>该行为是<code>/etc/firewalld/firewalld.conf</code>的<a href=https://firewalld.org/documentation/configuration/firewalld-conf.html>IPv6_rpfilter/etc/firewalld/firewalld.conf选项</a>控制的，需要将其改为：</p><pre tabindex=0><code>IPv6_rpfilter=no
</code></pre><p>对于nftables的更多使用方法以及概念学习，推荐看RedHat的<a href=https://access.redhat.com/documentation/zh-cn/red_hat_enterprise_linux/8/html/configuring_and_managing_networking/getting-started-with-nftables_configuring-and-managing-networking>这份文档</a>。</p><h1 id=参考文档>参考文档</h1><ul><li><a href=https://home.regit.org/2014/02/nftables-and-netfilter-logging-framework/>Nftables and the Netfilter logging framework</a></li><li><a href=https://wiki.nftables.org/wiki-nftables/index.php>nftables wiki</a></li><li><a href=https://tldp.org/HOWTO/Linux+IPv6-HOWTO/ch18s05.html>TLDP - Linux IPv6 HOWTO (en) - Firewalling using nftables</a></li></ul></main><div id=comments><hr><script src=https://utteranc.es/client.js repo=KB5201314/KB5201314.github.io issue-term=pathname label='💬 comments 💬' theme=github-light crossorigin=anonymous async></script></div><footer><hr>© imlk 2017 &ndash; 2021 | <a href=https://blog.imlk.top>imlk's blog</a> | <a href=https://github.com/KB5201314/>Github</a> | <a href=mailto:me@imlk.top>Email</a> | <a href=https://beian.miit.gov.cn/>京ICP备 - 2020042968号</a></footer></body></html>